# Real-Space UV展开工程化指南
**版本**: 1.0
**日期**: 2025-01-30
**配套文档**: MINI_UNFOLD3D_TECHNICAL_ROADMAP.md

---

## 目录

1. [Real-Space概念与重要性](#1-real-space概念与重要性)
2. [单位闭环管理](#2-单位闭环管理)
3. [失真评估指标体系](#3-失真评估指标体系)
4. [迭代闭环机制](#4-迭代闭环机制)
5. [配置参数体系](#5-配置参数体系)
6. [数据结构与文件格式](#6-数据结构与文件格式)
7. [跨缝处理详解](#7-跨缝处理详解)
8. [制造容差标准](#8-制造容差标准)
9. [常见陷阱与规避](#9-常见陷阱与规避)
10. [验证与校准流程](#10-验证与校准流程)
11. [性能优化策略](#11-性能优化策略)
12. [完整代码框架](#12-完整代码框架)

---

## 1. Real-Space概念与重要性

### 1.1 什么是Real-Space UV

**Real-Space (RS) UV** 是指UV坐标系统中的单位与真实物理世界保持一致的UV展开方式：

```
传统UV: [0,1] × [0,1] 归一化坐标
RS-UV:   物理单位 (如 mm, cm, inch)
```

**核心原则**:
- ✅ 1 UV单位 = 1 mm (或其他固定物理单位)
- ✅ UV空间的距离 = 3D表面测地距离
- ✅ 制造工艺直接使用UV坐标

### 1.2 为什么需要Real-Space

**应用场景**:
1. **3D打印纹理**: 激光雕刻、喷墨打印需要精确的物理尺寸
2. **贴膜制造**: 模具设计、薄膜切割要求1:1比例
3. **工业涂装**: 喷漆路径规划需要真实尺度
4. **质量控制**: 失真度容差以物理量纲定义

**传统UV的问题**:
- ❌ 归一化导致尺度信息丢失
- ❌ 不同UV岛比例不一致
- ❌ 无法直接用于CAM/CAD系统
- ❌ 制造误差难以量化

### 1.3 Real-Space的优势

| 特性 | 传统UV | Real-Space UV |
|------|--------|---------------|
| 单位 | 归一化[0,1] | 物理单位(mm) |
| 尺度 | 相对比例 | 绝对尺寸 |
| CAM集成 | 需要转换 | 直接使用 |
| 质量控制 | 定性评估 | 定量容差 |
| 跨岛一致性 | 难以保证 | 统一比例 |

---

## 2. 单位闭环管理

### 2.1 全链路单位统一

**核心要求**: IO → 预处理 → BFF → UV → SVG/PDF → CAM，全链路使用 **mm** 作为基准单位。

```cpp
// 单位管理配置
struct UnitConfig {
    enum class Unit { MM, CM, INCH, METER };

    Unit base_unit = Unit::MM;          // 基准单位: mm
    double unit_scale = 1.0;            // 到mm的缩放因子

    // 单位转换
    double to_mm(double value, Unit from) const {
        static const double scales[] = {1.0, 10.0, 25.4, 1000.0};
        return value * scales[static_cast<int>(from)];
    }

    double from_mm(double value, Unit to) const {
        return value / to_mm(1.0, to);
    }
};
```

### 2.2 加载阶段单位处理

```cpp
Mesh load_mesh_with_unit(const std::string& path, UnitConfig& cfg) {
    // 1. 检测输入文件单位
    auto detected_unit = detect_mesh_unit(path);  // 从文件头/注释获取

    // 2. 读取网格
    Mesh mesh = load_mesh(path);

    // 3. 统一缩放到mm
    if (detected_unit != UnitConfig::Unit::MM) {
        double scale = cfg.to_mm(1.0, detected_unit);
        for (auto v : mesh.vertices()) {
            mesh.point(v) *= scale;
        }
        std::cout << "Scaled mesh from " << unit_name(detected_unit)
                  << " to MM (factor: " << scale << ")" << std::endl;
    }

    // 4. 验证模型尺度合理性
    auto bbox = compute_bbox(mesh);
    double diagonal = bbox.diagonal().norm();
    if (diagonal < 1.0 || diagonal > 10000.0) {
        std::cerr << "Warning: Unusual mesh size " << diagonal
                  << "mm, please verify unit!" << std::endl;
    }

    return mesh;
}
```

### 2.3 BFF展开单位保持

```cpp
UVResult parametrize_bff_real_space(const Mesh& mesh,
                                     const CutResult& cuts,
                                     const RSConfig& cfg) {
    UVResult result;

    for (const auto& island : cuts.islands) {
        // 1. 提取岛的边界3D弧长 (单位: mm)
        std::vector<double> boundary_lengths_3d;
        for (auto edge : island.boundary_edges) {
            double len = mesh.calc_edge_length(edge);  // mm
            boundary_lengths_3d.push_back(len);
        }

        // 2. BFF求解，约束边界长度=3D长度
        BFFSolver bff(island.mesh);
        bff.set_boundary_lengths(boundary_lengths_3d);  // 关键：保持mm
        bff.solve();

        // 3. 获取UV坐标 (已是mm单位)
        auto uv = bff.get_uv_coordinates();

        // 4. 统一全局缩放 = 1 (不允许各岛独立缩放)
        double actual_scale = compute_average_scale(island.mesh, uv);
        if (std::abs(actual_scale - 1.0) > cfg.scale_tolerance) {
            std::cerr << "Warning: Island scale deviation: "
                      << actual_scale << std::endl;
            // 强制归一化
            for (auto& p : uv) {
                p /= actual_scale;
            }
        }

        result.islands_uv.push_back(uv);
    }

    return result;
}
```

### 2.4 导出阶段单位标注

```cpp
void export_uv_with_unit(const std::string& path,
                         const UVResult& uv,
                         const UnitConfig& cfg) {
    std::ofstream file(path);

    // OBJ文件头注释标注单位
    file << "# UV coordinates in Real-Space\n";
    file << "# Unit: " << unit_name(cfg.base_unit) << "\n";
    file << "# 1 UV unit = 1 " << unit_name(cfg.base_unit) << "\n";
    file << "# Generated by Mini-Unfold3D\n\n";

    // 写入顶点 (保持mm单位)
    for (const auto& p : uv.vertices) {
        file << "v " << p.x << " " << p.y << " " << p.z << "\n";
    }

    // 写入UV坐标 (mm单位)
    for (const auto& uv : uv.uvs) {
        file << "vt " << uv.x << " " << uv.y << "\n";
    }

    // ... 写入面
}

void export_svg_real_scale(const std::string& path,
                           const UVResult& uv,
                           const PathsD& patterns) {
    // SVG单位设置为mm
    std::ofstream svg(path);
    svg << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    svg << "<svg xmlns=\"http://www.w3.org/2000/svg\" ";

    // 关键：viewBox单位为mm，1:1比例
    auto bbox = compute_uv_bbox(uv);
    svg << "viewBox=\"" << bbox.min.x << " " << bbox.min.y << " "
        << bbox.width() << " " << bbox.height() << "\" ";
    svg << "width=\"" << bbox.width() << "mm\" ";
    svg << "height=\"" << bbox.height() << "mm\">\n";

    // 添加1:1比例标尺
    draw_scale_ruler(svg, 10.0);  // 10mm刻度

    // 添加定位靶标
    draw_alignment_marks(svg, bbox);

    // 绘制UV岛轮廓
    for (const auto& island : uv.islands) {
        svg << "<path d=\"";
        for (const auto& p : island.boundary) {
            svg << (i == 0 ? "M" : "L") << p.x << "," << p.y << " ";
        }
        svg << "Z\" stroke=\"black\" stroke-width=\"0.1\" fill=\"none\"/>\n";
    }

    // 绘制图案
    for (const auto& path : patterns) {
        // ... 输出路径，单位已是mm
    }

    svg << "</svg>\n";
}
```

---

## 3. 失真评估指标体系

### 3.1 数学基础：雅可比矩阵

对于3D曲面的参数化 φ: (u,v) → (x,y,z)，雅可比矩阵为：

```
J = [∂x/∂u  ∂x/∂v]
    [∂y/∂u  ∂y/∂v]
    [∂z/∂u  ∂z/∂v]
```

对于离散三角网格，每个三角形的雅可比可通过有限差分计算：

```cpp
Eigen::Matrix2d compute_jacobian_2x2(const Triangle3D& tri_3d,
                                     const Triangle2D& tri_uv) {
    // 3D边向量
    Vector3 e1_3d = tri_3d.v1 - tri_3d.v0;
    Vector3 e2_3d = tri_3d.v2 - tri_3d.v0;

    // UV边向量
    Vector2 e1_uv = tri_uv.v1 - tri_uv.v0;
    Vector2 e2_uv = tri_uv.v2 - tri_uv.v0;

    // UV → 3D 的雅可比
    // [e1_3d e2_3d] = J * [e1_uv e2_uv]
    Eigen::Matrix2d UV;
    UV << e1_uv.x, e2_uv.x,
          e1_uv.y, e2_uv.y;

    Eigen::Matrix<double, 3, 2> P3D;
    P3D << e1_3d.x, e2_3d.x,
           e1_3d.y, e2_3d.y,
           e1_3d.z, e2_3d.z;

    // J = P3D * UV^{-1}
    Eigen::Matrix<double, 3, 2> J = P3D * UV.inverse();

    // 计算第一基本形式 I = J^T * J
    Eigen::Matrix2d I = J.transpose() * J;

    return I;
}
```

### 3.2 三种核心失真指标

#### 3.2.1 长度拉伸 (Stretch Distortion)

通过SVD分解第一基本形式矩阵：

```cpp
struct StretchMetrics {
    double sigma_min;  // 最小奇异值 (最小拉伸)
    double sigma_max;  // 最大奇异值 (最大拉伸)
    Vector2 dir_min;   // 最小拉伸方向
    Vector2 dir_max;   // 最大拉伸方向
};

StretchMetrics compute_stretch(const Eigen::Matrix2d& I) {
    // SVD分解: I = U * Σ * V^T
    Eigen::JacobiSVD<Eigen::Matrix2d> svd(I,
        Eigen::ComputeFullU | Eigen::ComputeFullV);

    StretchMetrics metrics;
    auto singular_values = svd.singularValues();

    // 奇异值即为主拉伸量
    metrics.sigma_max = std::sqrt(singular_values(0));
    metrics.sigma_min = std::sqrt(singular_values(1));

    // 主方向
    auto U = svd.matrixU();
    metrics.dir_max = U.col(0);
    metrics.dir_min = U.col(1);

    return metrics;
}
```

**物理意义**:
- σ_max = 1.0: 完美保持该方向长度
- σ_max = 1.1: 该方向拉伸了10%
- σ_min = 0.9: 该方向压缩了10%

#### 3.2.2 共形误差 (Conformal Error)

**定义**: 衡量是否保持角度的指标

```cpp
double compute_conformal_error(const StretchMetrics& stretch) {
    // QC = σ_max / σ_min
    // QC = 1.0 表示完美共形 (角度保持)
    // QC > 1.0 表示各向异性拉伸
    return stretch.sigma_max / stretch.sigma_min;
}
```

**制造容差**:
```cpp
enum class ConformalQuality {
    EXCELLENT,  // QC ≤ 1.05  (5%以内)
    GOOD,       // QC ≤ 1.10  (10%以内)
    ACCEPTABLE, // QC ≤ 1.15  (15%以内)
    POOR        // QC > 1.15
};

ConformalQuality classify_conformal_quality(double QC) {
    if (QC <= 1.05) return ConformalQuality::EXCELLENT;
    if (QC <= 1.10) return ConformalQuality::GOOD;
    if (QC <= 1.15) return ConformalQuality::ACCEPTABLE;
    return ConformalQuality::POOR;
}
```

#### 3.2.3 面积失真 (Area Distortion)

```cpp
double compute_area_distortion(const Triangle3D& tri_3d,
                               const Triangle2D& tri_uv) {
    double area_3d = compute_triangle_area_3d(tri_3d);  // mm²
    double area_uv = compute_triangle_area_2d(tri_uv);  // mm²

    // 面积比
    double area_ratio = area_uv / area_3d;

    // 理想情况: area_ratio ≈ 1.0
    // > 1.0: UV空间膨胀
    // < 1.0: UV空间收缩

    return area_ratio;
}
```

### 3.3 颜色编码方案

```cpp
struct ColorMap {
    // Heatmap: 失真小(蓝色) → 失真大(红色)
    glm::vec3 get_color_for_stretch(double sigma_max) {
        // 定义颜色断点
        const double thresholds[] = {1.00, 1.05, 1.10, 1.15, 1.20};
        const glm::vec3 colors[] = {
            {0.0, 0.0, 1.0},  // 蓝色 (完美)
            {0.0, 1.0, 0.0},  // 绿色 (优秀)
            {1.0, 1.0, 0.0},  // 黄色 (可接受)
            {1.0, 0.5, 0.0},  // 橙色 (警告)
            {1.0, 0.0, 0.0}   // 红色 (失败)
        };

        // 线性插值
        for (int i = 0; i < 4; ++i) {
            if (sigma_max <= thresholds[i+1]) {
                double t = (sigma_max - thresholds[i]) /
                           (thresholds[i+1] - thresholds[i]);
                return glm::mix(colors[i], colors[i+1], t);
            }
        }

        return colors[4];  // 超过最大阈值，返回红色
    }
};
```

### 3.4 完整的失真分析器

```cpp
class UVDistortionAnalyzer {
public:
    struct PerFaceMetrics {
        double sigma_min;
        double sigma_max;
        double conformal_error;  // QC
        double area_ratio;
        glm::vec3 color;         // 可视化颜色
    };

    struct GlobalStatistics {
        double mean_sigma_max;
        double std_sigma_max;
        double max_sigma_max;
        double percentile_95_sigma_max;

        double mean_conformal_error;
        double max_conformal_error;

        int num_excellent_faces;   // QC ≤ 1.05
        int num_good_faces;         // QC ≤ 1.10
        int num_acceptable_faces;   // QC ≤ 1.15
        int num_poor_faces;         // QC > 1.15

        double pass_rate;  // 在容差内的面片比例
    };

    struct AnalysisResult {
        std::vector<PerFaceMetrics> per_face;
        GlobalStatistics statistics;
        std::vector<glm::vec3> vertex_colors;  // 用于渲染
    };

    AnalysisResult analyze(const Mesh& mesh,
                          const Geometry& geometry,
                          const UVMapping& uv_map,
                          double threshold = 1.10) {
        AnalysisResult result;
        result.per_face.resize(mesh.num_faces());

        ColorMap colormap;

        // 1. 计算每个面的失真
        for (Face f : mesh.faces()) {
            auto tri_3d = get_triangle_3d(f, geometry);
            auto tri_uv = get_triangle_uv(f, uv_map);

            // 计算雅可比和度量
            auto I = compute_jacobian_2x2(tri_3d, tri_uv);
            auto stretch = compute_stretch(I);

            PerFaceMetrics& metrics = result.per_face[f.idx()];
            metrics.sigma_min = stretch.sigma_min;
            metrics.sigma_max = stretch.sigma_max;
            metrics.conformal_error = compute_conformal_error(stretch);
            metrics.area_ratio = compute_area_distortion(tri_3d, tri_uv);
            metrics.color = colormap.get_color_for_stretch(metrics.sigma_max);
        }

        // 2. 计算全局统计
        result.statistics = compute_statistics(result.per_face, threshold);

        // 3. 平滑到顶点颜色 (用于渲染)
        result.vertex_colors = smooth_face_colors_to_vertices(
            mesh, result.per_face);

        return result;
    }

private:
    GlobalStatistics compute_statistics(
        const std::vector<PerFaceMetrics>& metrics,
        double threshold) {

        GlobalStatistics stats{};

        std::vector<double> sigma_maxs;
        for (const auto& m : metrics) {
            sigma_maxs.push_back(m.sigma_max);

            // 分类统计
            if (m.conformal_error <= 1.05) {
                stats.num_excellent_faces++;
            } else if (m.conformal_error <= 1.10) {
                stats.num_good_faces++;
            } else if (m.conformal_error <= 1.15) {
                stats.num_acceptable_faces++;
            } else {
                stats.num_poor_faces++;
            }
        }

        // 均值和标准差
        stats.mean_sigma_max = compute_mean(sigma_maxs);
        stats.std_sigma_max = compute_std(sigma_maxs);
        stats.max_sigma_max = *std::max_element(
            sigma_maxs.begin(), sigma_maxs.end());

        // 95分位数
        std::sort(sigma_maxs.begin(), sigma_maxs.end());
        stats.percentile_95_sigma_max =
            sigma_maxs[sigma_maxs.size() * 0.95];

        // 通过率
        int pass_count = std::count_if(sigma_maxs.begin(), sigma_maxs.end(),
            [threshold](double s) { return s <= threshold; });
        stats.pass_rate = static_cast<double>(pass_count) / sigma_maxs.size();

        return stats;
    }
};
```

---

## 4. 迭代闭环机制

### 4.1 失真驱动的自动返修

```cpp
class IterativeUVOptimizer {
public:
    struct IterationConfig {
        int max_iterations = 5;
        double target_sigma_max = 1.10;
        double improvement_threshold = 0.02;  // 改善<2%则停止
        bool auto_add_cuts = true;
    };

    struct IterationResult {
        UVMapping final_uv;
        CutResult final_cuts;
        std::vector<DistortionAnalysis> history;
        int num_iterations;
        bool converged;
    };

    IterationResult optimize(Mesh& mesh,
                            Geometry& geometry,
                            const IterationConfig& config) {
        IterationResult result;

        // 初始切缝
        CutResult cuts = initial_cut(mesh, geometry);

        for (int iter = 0; iter < config.max_iterations; ++iter) {
            std::cout << "\n=== Iteration " << iter + 1 << " ===" << std::endl;

            // 1. BFF展开
            auto uv = parametrize_bff_real_space(mesh, cuts, rs_config);

            // 2. 失真分析
            UVDistortionAnalyzer analyzer;
            auto distortion = analyzer.analyze(mesh, geometry, uv,
                                              config.target_sigma_max);

            result.history.push_back(distortion);

            std::cout << "Max σ_max: " << distortion.statistics.max_sigma_max
                      << std::endl;
            std::cout << "95% σ_max: " << distortion.statistics.percentile_95_sigma_max
                      << std::endl;
            std::cout << "Pass rate: " << (distortion.statistics.pass_rate * 100)
                      << "%" << std::endl;

            // 3. 检查收敛
            if (distortion.statistics.percentile_95_sigma_max <=
                config.target_sigma_max) {
                std::cout << "Converged! Target achieved." << std::endl;
                result.converged = true;
                result.final_uv = uv;
                result.final_cuts = cuts;
                result.num_iterations = iter + 1;
                break;
            }

            // 4. 检查改善幅度
            if (iter > 0) {
                double prev_max = result.history[iter-1].statistics.max_sigma_max;
                double curr_max = distortion.statistics.max_sigma_max;
                double improvement = (prev_max - curr_max) / prev_max;

                if (improvement < config.improvement_threshold) {
                    std::cout << "Improvement < "
                              << (config.improvement_threshold * 100)
                              << "%, stopping." << std::endl;
                    result.converged = false;
                    result.final_uv = uv;
                    result.final_cuts = cuts;
                    result.num_iterations = iter + 1;
                    break;
                }
            }

            // 5. 自动添加新切缝
            if (config.auto_add_cuts) {
                cuts = refine_cuts_based_on_distortion(
                    mesh, geometry, uv, distortion, cuts);
            } else {
                std::cout << "Auto-add-cuts disabled, stopping." << std::endl;
                result.converged = false;
                result.final_uv = uv;
                result.final_cuts = cuts;
                result.num_iterations = iter + 1;
                break;
            }
        }

        return result;
    }

private:
    CutResult refine_cuts_based_on_distortion(
        const Mesh& mesh,
        const Geometry& geometry,
        const UVMapping& uv,
        const DistortionAnalysis& distortion,
        const CutResult& current_cuts) {

        // 1. 找出高失真区域 (σ_max > threshold)
        std::vector<Face> hotspots;
        for (Face f : mesh.faces()) {
            if (distortion.per_face[f.idx()].sigma_max >
                rs_config.stretch_thresh) {
                hotspots.push_back(f);
            }
        }

        std::cout << "Found " << hotspots.size()
                  << " hotspot faces" << std::endl;

        if (hotspots.empty()) {
            return current_cuts;  // 没有高失真区域
        }

        // 2. 聚类高失真区域
        auto clusters = cluster_faces(hotspots, mesh);

        // 3. 为每个聚类添加切缝
        CutResult new_cuts = current_cuts;

        for (const auto& cluster : clusters) {
            // 分析该聚类的拉伸主方向
            Vector3 principal_direction = compute_principal_stretch_direction(
                cluster, distortion);

            // 沿主方向添加切缝
            auto new_seam = compute_optimal_cut_in_direction(
                mesh, geometry, cluster, principal_direction);

            if (!new_seam.empty()) {
                new_cuts.seams.push_back(new_seam);
                std::cout << "Added new seam with " << new_seam.size()
                          << " edges" << std::endl;
            }
        }

        // 4. 重新计算岛
        new_cuts.islands = extract_islands_from_seams(mesh, new_cuts.seams);

        return new_cuts;
    }
};
```

### 4.2 自适应切缝策略

```cpp
std::vector<Edge> compute_optimal_cut_in_direction(
    const Mesh& mesh,
    const Geometry& geometry,
    const std::vector<Face>& region,
    const Vector3& direction) {

    // 1. 在区域内建立方向场
    std::map<Face, Vector3> direction_field;
    for (Face f : region) {
        // 将全局方向投影到面切平面
        Vector3 normal = geometry.faceNormal(f);
        Vector3 projected = direction - dot(direction, normal) * normal;
        projected.normalize();
        direction_field[f] = projected;
    }

    // 2. 沿方向场积分找流线
    auto streamline = trace_streamline(mesh, geometry,
                                       region, direction_field);

    // 3. 将流线对齐到网格边
    auto cut_edges = snap_curve_to_edges(mesh, streamline);

    return cut_edges;
}
```

---

## 5. 配置参数体系

### 5.1 Real-Space配置结构

```cpp
struct RSConfig {
    // ========== 单位与尺度 ==========
    double unit_scale_mm = 1.0;       // 1 UV unit = 1 mm
    std::string unit_name = "mm";

    // ========== 预处理参数 ==========
    double target_edge_len = 0.5;     // remesh 目标边长 (mm)
    double min_triangle_angle = 10.0; // 最小三角形角度 (度)
    double max_aspect_ratio = 3.0;    // 最大长宽比
    bool remove_degenerates = true;   // 移除退化三角形
    bool stitch_boundaries = true;    // 缝合边界

    // ========== 切缝参数 ==========
    double curvature_weight = 1.0;    // 曲率权重
    double length_penalty = 0.1;      // 缝长惩罚
    double island_count_penalty = 0.5;// 岛数量惩罚
    int max_islands = 10;             // 最大岛数量
    bool respect_feature_edges = true;// 尊重特征边

    // ========== BFF参数 ==========
    bool use_conformal = true;        // 使用共形映射
    bool auto_detect_cones = true;    // 自动检测锥点
    double cone_angle_threshold = 30.0; // 锥点角度阈值 (度)
    bool preserve_boundary_lengths = true; // 保持边界长度

    // ========== 失真阈值 ==========
    double stretch_thresh = 1.10;     // σ_max 阈值
    double conformal_thresh = 1.10;   // QC 阈值
    double area_thresh = 1.15;        // 面积比阈值
    double angle_thresh = 5.0;        // 角度误差阈值 (度)

    // ========== 迭代参数 ==========
    int max_iterations = 5;           // 最大迭代次数
    double improvement_threshold = 0.02; // 改善阈值
    bool auto_refine_cuts = true;     // 自动优化切缝

    // ========== 制造参数 ==========
    double kerf = 0.1;                // 激光/刀具直径(mm)
    double safety_gap = 0.2;          // 图案与边界间隙(mm)
    double min_feature_size = 0.5;    // 最小特征尺寸(mm)
    double wall_thickness = 2.0;      // 壁厚(mm)

    // ========== 校准参数 ==========
    double scale_x = 1.0;             // X方向缩放补偿
    double scale_y = 1.0;             // Y方向缩放补偿
    double shear = 0.0;               // 剪切补偿
    double rotation = 0.0;            // 旋转补偿 (度)

    // ========== 输出参数 ==========
    bool export_uv_obj = true;
    bool export_svg = true;
    bool export_pdf = false;
    bool export_step = true;
    bool export_report = true;
    int svg_resolution = 2048;        // SVG分辨率 (像素)

    // ========== 可视化参数 ==========
    enum class ColorScheme {
        HEATMAP,        // 热图 (蓝→绿→黄→红)
        TRAFFIC_LIGHT,  // 交通灯 (绿→黄→红)
        GRAYSCALE,      // 灰度
        RAINBOW         // 彩虹
    };
    ColorScheme color_scheme = ColorScheme::HEATMAP;
    bool show_distortion_legend = true;
    bool show_scale_ruler = true;

    // ========== 性能参数 ==========
    int num_threads = 0;              // 0 = 自动检测
    bool use_gpu = false;             // 使用GPU加速
    size_t max_memory_mb = 4096;      // 最大内存使用(MB)

    // 加载配置文件
    static RSConfig load_from_json(const std::string& path);

    // 保存配置文件
    void save_to_json(const std::string& path) const;

    // 验证配置合法性
    bool validate(std::string& error_msg) const;
};
```

### 5.2 配置文件示例 (JSON)

```json
{
  "unit": {
    "scale_mm": 1.0,
    "name": "mm"
  },
  "preprocessing": {
    "target_edge_length": 0.5,
    "min_triangle_angle": 10.0,
    "max_aspect_ratio": 3.0,
    "remove_degenerates": true,
    "stitch_boundaries": true
  },
  "cutting": {
    "curvature_weight": 1.0,
    "length_penalty": 0.1,
    "island_count_penalty": 0.5,
    "max_islands": 10,
    "respect_feature_edges": true
  },
  "bff": {
    "use_conformal": true,
    "auto_detect_cones": true,
    "cone_angle_threshold": 30.0,
    "preserve_boundary_lengths": true
  },
  "distortion_thresholds": {
    "stretch_max": 1.10,
    "conformal_max": 1.10,
    "area_ratio_max": 1.15,
    "angle_error_max": 5.0
  },
  "iteration": {
    "max_iterations": 5,
    "improvement_threshold": 0.02,
    "auto_refine_cuts": true
  },
  "manufacturing": {
    "kerf_mm": 0.1,
    "safety_gap_mm": 0.2,
    "min_feature_size_mm": 0.5,
    "wall_thickness_mm": 2.0
  },
  "calibration": {
    "scale_x": 1.0,
    "scale_y": 1.0,
    "shear": 0.0,
    "rotation_deg": 0.0
  },
  "output": {
    "export_uv_obj": true,
    "export_svg": true,
    "export_pdf": false,
    "export_step": true,
    "export_report": true,
    "svg_resolution": 2048
  },
  "visualization": {
    "color_scheme": "HEATMAP",
    "show_distortion_legend": true,
    "show_scale_ruler": true
  },
  "performance": {
    "num_threads": 0,
    "use_gpu": false,
    "max_memory_mb": 4096
  }
}
```

---

## 6. 数据结构与文件格式

### 6.1 核心数据结构

```cpp
// Mesh with attributes
using Mesh = CGAL::Surface_mesh<CGAL::Exact_predicates_inexact_constructions_kernel::Point_3>;

// Seam representation
struct SeamInfo {
    std::unordered_set<Mesh::Edge_index> edges;  // 缝边集合
    std::map<Mesh::Edge_index, int> island_ids;  // 边所属岛ID

    struct SeamSide {
        Mesh::Halfedge_index halfedge;
        int island_id;
    };

    // 缝的两侧映射 (用于跨缝图案拼接)
    std::map<Mesh::Halfedge_index, Mesh::Halfedge_index> glue_map;
};

// UV coordinates (Real-Space, unit: mm)
struct UVCoordinates {
    std::vector<Eigen::Vector2d> coords;  // per-vertex UV (mm)
    std::vector<int> island_ids;          // 顶点所属岛ID

    // 岛边界信息
    struct IslandBoundary {
        std::vector<Eigen::Vector2d> boundary_points;  // mm
        double perimeter;                              // mm
        double area;                                   // mm²
        Eigen::AlignedBox2d bbox;                      // mm
    };
    std::vector<IslandBoundary> islands;
};

// Distortion metrics
struct DistortionData {
    // Per-face metrics
    std::vector<double> sigma_min;
    std::vector<double> sigma_max;
    std::vector<double> conformal_error;
    std::vector<double> area_ratio;

    // Statistics
    double mean_sigma_max;
    double std_sigma_max;
    double max_sigma_max;
    double percentile_95_sigma_max;
    double pass_rate;
};

// Pattern paths (UV space, unit: mm)
using PathsD = Clipper2Lib::PathsD;  // 已经是double，单位mm

struct PatternData {
    PathsD paths_uv;              // UV空间路径 (mm)
    double total_length;          // 总长度 (mm)
    double coverage_ratio;        // 覆盖率
    int num_paths;                // 路径数量
};

// 3D mapped curves
struct Curves3D {
    std::vector<std::vector<Eigen::Vector3d>> curves;  // mm
    std::vector<double> curve_lengths;                 // mm
    double total_length;                               // mm
};
```

### 6.2 导出格式规范

#### 6.2.1 OBJ格式 (Real-Space)

```
# UV coordinates in Real-Space
# Unit: mm
# 1 UV unit = 1 mm
# Generated by Mini-Unfold3D v1.0
# Date: 2025-01-30

# Vertices (3D, mm)
v 10.5 20.3 5.7
v 11.2 19.8 5.9
...

# UV coordinates (Real-Space, mm)
vt 45.2 78.3
vt 46.1 77.9
...

# Normals
vn 0.707 0.707 0.0
...

# Faces
f 1/1/1 2/2/2 3/3/3
...

# Island metadata (comment)
# Island 0: area=125.3mm², perimeter=48.2mm, σ_max=1.08
# Island 1: area=89.7mm², perimeter=39.1mm, σ_max=1.12
```

#### 6.2.2 SVG格式 (1:1比例)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 200 150"
     width="200mm" height="150mm">

  <!-- 标尺 (10mm刻度) -->
  <g id="ruler">
    <line x1="10" y1="5" x2="20" y2="5"
          stroke="black" stroke-width="0.2"/>
    <text x="15" y="3" font-size="2">10mm</text>
  </g>

  <!-- 定位靶标 -->
  <g id="alignment-marks">
    <circle cx="10" cy="10" r="2"
            stroke="black" fill="none" stroke-width="0.1"/>
    <circle cx="190" cy="10" r="2"
            stroke="black" fill="none" stroke-width="0.1"/>
  </g>

  <!-- UV岛轮廓 -->
  <g id="uv-islands">
    <path d="M45.2,78.3 L46.1,77.9 L..."
          stroke="blue" stroke-width="0.1" fill="none"/>
  </g>

  <!-- 填充图案 -->
  <g id="patterns">
    <path d="M..."
          stroke="red" stroke-width="0.05" fill="none"/>
  </g>

  <!-- 元数据 -->
  <metadata>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rs:RealSpace xmlns:rs="http://mini-unfold3d.org/rs">
        <rs:unit>mm</rs:unit>
        <rs:scale>1.0</rs:scale>
        <rs:distortion_max>1.08</rs:distortion_max>
      </rs:RealSpace>
    </rdf:RDF>
  </metadata>
</svg>
```

#### 6.2.3 STEP格式 (3D曲线)

```cpp
void export_curves_step(const std::string& path,
                        const Curves3D& curves) {
    // 使用OpenCascade或类似库
    Handle(TDocStd_Document) doc = ...;

    for (const auto& curve : curves.curves) {
        // 创建B样条曲线
        TColgp_Array1OfPnt poles(1, curve.size());
        for (size_t i = 0; i < curve.size(); ++i) {
            poles.SetValue(i+1, gp_Pnt(
                curve[i].x(), curve[i].y(), curve[i].z()));
        }

        Handle(Geom_BSplineCurve) bspline =
            GeomAPI_PointsToBSpline(poles).Curve();

        // 添加到文档
        ...
    }

    // 导出STEP
    STEPControl_Writer writer;
    writer.Transfer(doc, STEPControl_AsIs);
    writer.Write(path.c_str());
}
```

#### 6.2.4 JSON报告格式

```json
{
  "metadata": {
    "version": "1.0",
    "generator": "Mini-Unfold3D",
    "date": "2025-01-30T10:30:00Z",
    "input_file": "spot.obj",
    "unit": "mm"
  },
  "mesh_info": {
    "num_vertices": 2904,
    "num_faces": 5804,
    "bbox_min": [-50.2, -30.1, 0.0],
    "bbox_max": [50.3, 30.2, 80.5],
    "surface_area_mm2": 15234.7,
    "is_manifold": true,
    "is_closed": true,
    "genus": 0
  },
  "islands": [
    {
      "id": 0,
      "num_faces": 3200,
      "area_mm2": 125.3,
      "perimeter_mm": 48.2,
      "bbox": {"min": [0, 0], "max": [45.2, 78.3]},
      "distortion": {
        "max_sigma_max": 1.08,
        "mean_sigma_max": 1.03,
        "percentile_95_sigma_max": 1.06,
        "pass_rate": 0.95
      }
    },
    {
      "id": 1,
      "num_faces": 2604,
      "area_mm2": 89.7,
      "perimeter_mm": 39.1,
      "bbox": {"min": [50, 0], "max": [85.3, 62.1]},
      "distortion": {
        "max_sigma_max": 1.12,
        "mean_sigma_max": 1.05,
        "percentile_95_sigma_max": 1.09,
        "pass_rate": 0.88
      }
    }
  ],
  "global_distortion": {
    "max_sigma_max": 1.12,
    "mean_sigma_max": 1.04,
    "std_sigma_max": 0.03,
    "percentile_95_sigma_max": 1.09,
    "overall_pass_rate": 0.92,
    "num_excellent_faces": 4523,
    "num_good_faces": 982,
    "num_acceptable_faces": 254,
    "num_poor_faces": 45
  },
  "patterns": {
    "num_paths": 127,
    "total_length_mm": 3245.8,
    "coverage_ratio": 0.35
  },
  "quality_control": {
    "threshold_sigma_max": 1.10,
    "pass": true,
    "issues": []
  },
  "processing_time": {
    "preprocessing_sec": 0.8,
    "cutting_sec": 2.3,
    "parametrization_sec": 1.5,
    "distortion_analysis_sec": 0.3,
    "pattern_filling_sec": 0.7,
    "3d_mapping_sec": 1.1,
    "total_sec": 6.7
  }
}
```

---

## 7. 跨缝处理详解

### 7.1 缝映射数据结构

```cpp
struct SeamGlueMap {
    // 缝两侧半边的双射
    std::map<Mesh::Halfedge_index, Mesh::Halfedge_index> glue;

    // 边参数化：对于缝边e，记录其在两侧岛上的UV参数
    struct EdgeParametrization {
        std::vector<double> parameters;  // t ∈ [0,1]
        std::vector<Eigen::Vector2d> uv_left;   // 左侧岛UV
        std::vector<Eigen::Vector2d> uv_right;  // 右侧岛UV
    };
    std::map<Mesh::Edge_index, EdgeParametrization> edge_params;

    // 构建缝映射
    void build(const Mesh& mesh, const SeamInfo& seams) {
        for (auto edge : seams.edges) {
            auto he0 = mesh.halfedge(edge, 0);
            auto he1 = mesh.halfedge(edge, 1);

            // 建立双射
            glue[he0] = he1;
            glue[he1] = he0;

            // 沿边采样UV参数
            const int num_samples = 10;
            EdgeParametrization& param = edge_params[edge];
            param.parameters.resize(num_samples);
            param.uv_left.resize(num_samples);
            param.uv_right.resize(num_samples);

            for (int i = 0; i < num_samples; ++i) {
                double t = static_cast<double>(i) / (num_samples - 1);
                param.parameters[i] = t;

                // 插值两侧UV坐标
                auto v0 = mesh.source(he0);
                auto v1 = mesh.target(he0);
                param.uv_left[i] = (1-t) * uv_coords[v0] + t * uv_coords[v1];

                auto v2 = mesh.source(he1);
                auto v3 = mesh.target(he1);
                param.uv_right[i] = (1-t) * uv_coords[v2] + t * uv_coords[v3];
            }
        }
    }
};
```

### 7.2 跨缝路径映射

```cpp
class CrossSeamMapper {
public:
    // 映射跨越缝线的UV路径到3D
    std::vector<Eigen::Vector3d> map_cross_seam_path(
        const std::vector<Eigen::Vector2d>& uv_path,
        const Mesh& mesh,
        const UVCoordinates& uv_coords,
        const SeamGlueMap& glue_map) {

        std::vector<Eigen::Vector3d> path_3d;

        for (size_t i = 0; i < uv_path.size() - 1; ++i) {
            auto p0 = uv_path[i];
            auto p1 = uv_path[i+1];

            // 1. 定位p0和p1所在的三角形
            auto [face0, bary0] = locate_triangle(p0, mesh, uv_coords);
            auto [face1, bary1] = locate_triangle(p1, mesh, uv_coords);

            // 2. 检查是否跨越缝线
            if (face0.island_id == face1.island_id) {
                // 同一岛内，直接映射
                path_3d.push_back(interpolate_3d(face0, bary0, mesh));

            } else {
                // 跨缝，需要特殊处理
                auto crossing = find_seam_crossing(
                    p0, p1, face0, face1, mesh, uv_coords, glue_map);

                if (crossing.has_value()) {
                    // 在缝边上插入交点
                    path_3d.push_back(crossing->point_3d);

                    // 可选：使用最短路径在3D上连接
                    if (use_geodesic_path) {
                        auto geodesic = compute_surface_shortest_path(
                            crossing->point_3d,
                            interpolate_3d(face1, bary1, mesh),
                            mesh);
                        path_3d.insert(path_3d.end(),
                                      geodesic.begin(), geodesic.end());
                    }
                }
            }
        }

        // 添加最后一个点
        auto [faceN, baryN] = locate_triangle(uv_path.back(), mesh, uv_coords);
        path_3d.push_back(interpolate_3d(faceN, baryN, mesh));

        return path_3d;
    }

private:
    struct SeamCrossing {
        Eigen::Vector2d point_uv;
        Eigen::Vector3d point_3d;
        Mesh::Edge_index seam_edge;
        double parameter_t;  // t ∈ [0,1] on seam edge
    };

    std::optional<SeamCrossing> find_seam_crossing(
        const Eigen::Vector2d& uv_p0,
        const Eigen::Vector2d& uv_p1,
        const FaceInfo& face0,
        const FaceInfo& face1,
        const Mesh& mesh,
        const UVCoordinates& uv_coords,
        const SeamGlueMap& glue_map) {

        // 1. 找到face0和face1之间的共享缝边
        auto shared_edge = find_shared_seam_edge(
            face0.island_id, face1.island_id, glue_map);

        if (!shared_edge.has_value()) {
            return std::nullopt;  // 没有直接相邻的缝
        }

        // 2. 计算UV线段与缝边的交点
        auto edge_param = glue_map.edge_params.at(*shared_edge);

        // UV空间中缝边的两侧表示
        std::vector<Eigen::Vector2d> seam_uv_left = edge_param.uv_left;
        std::vector<Eigen::Vector2d> seam_uv_right = edge_param.uv_right;

        // 线段p0-p1与缝边的交点
        auto intersection = intersect_segment_with_polyline(
            uv_p0, uv_p1, seam_uv_left);  // 或seam_uv_right，取决于face0在哪侧

        if (!intersection.has_value()) {
            return std::nullopt;
        }

        // 3. 计算交点的3D坐标
        double t = intersection->parameter;  // 在缝边上的参数

        auto v0 = mesh.source(*shared_edge);
        auto v1 = mesh.target(*shared_edge);
        auto p3d_v0 = mesh.point(v0);
        auto p3d_v1 = mesh.point(v1);

        Eigen::Vector3d crossing_3d =
            (1-t) * to_eigen(p3d_v0) + t * to_eigen(p3d_v1);

        return SeamCrossing{
            intersection->point_uv,
            crossing_3d,
            *shared_edge,
            t
        };
    }
};
```

### 7.3 CGAL最短路径集成

```cpp
#include <CGAL/Surface_mesh_shortest_path.h>

class SurfacePathComputer {
public:
    using Traits = CGAL::Surface_mesh_shortest_path_traits<Kernel, Mesh>;
    using SSPP = CGAL::Surface_mesh_shortest_path<Traits>;

    std::vector<Eigen::Vector3d> compute_geodesic_path(
        const Eigen::Vector3d& start,
        const Eigen::Vector3d& end,
        const Mesh& mesh) {

        SSPP sspp(mesh);

        // 1. 定位起点和终点在网格上的位置
        auto start_loc = locate_point_on_surface(start, mesh);
        auto end_loc = locate_point_on_surface(end, mesh);

        // 2. 计算最短路径
        sspp.add_source_point(start_loc.face, start_loc.barycentric);

        std::vector<Traits::Point_3> path_points;
        sspp.shortest_path_points_to_source_points(
            end_loc.face, end_loc.barycentric,
            std::back_inserter(path_points));

        // 3. 转换为Eigen格式
        std::vector<Eigen::Vector3d> result;
        for (const auto& p : path_points) {
            result.push_back(Eigen::Vector3d(p.x(), p.y(), p.z()));
        }

        return result;
    }

private:
    struct SurfaceLocation {
        Mesh::Face_index face;
        std::array<double, 3> barycentric;
    };

    SurfaceLocation locate_point_on_surface(
        const Eigen::Vector3d& point,
        const Mesh& mesh) {

        // 使用CGAL AABB树找到最近的面
        using Tree = CGAL::AABB_tree<
            CGAL::AABB_traits<Kernel,
                              CGAL::AABB_face_graph_triangle_primitive<Mesh>>>;

        Tree tree(faces(mesh).first, faces(mesh).second, mesh);
        tree.build();

        Point_3 query(point.x(), point.y(), point.z());
        auto closest = tree.closest_point_and_primitive(query);

        // 计算重心坐标
        auto face = closest.second;
        auto proj_point = closest.first;
        auto bary = compute_barycentric_coords(proj_point, face, mesh);

        return {face, bary};
    }
};
```

---

## 8. 制造容差标准

### 8.1 不同工艺的容差要求

```cpp
struct ManufacturingTolerance {
    enum class Process {
        SILK_SCREEN,      // 丝网印刷
        LASER_ENGRAVING,  // 激光雕刻
        VINYL_CUTTING,    // 贴膜切割
        CNC_MILLING,      // CNC铣削
        3D_PRINTING       // 3D打印纹理
    };

    struct ToleranceSpec {
        double max_stretch;        // 最大拉伸比
        double max_conformal_error; // 最大共形误差
        double max_area_deviation; // 最大面积偏差
        double min_feature_size;   // 最小特征尺寸 (mm)
        double positional_accuracy; // 定位精度 (mm)
    };

    static ToleranceSpec get_tolerance(Process process) {
        switch (process) {
            case Process::SILK_SCREEN:
                return {
                    .max_stretch = 1.10,        // 10%
                    .max_conformal_error = 1.10,
                    .max_area_deviation = 0.15,  // 15%
                    .min_feature_size = 1.0,     // 1mm
                    .positional_accuracy = 0.5   // 0.5mm
                };

            case Process::LASER_ENGRAVING:
                return {
                    .max_stretch = 1.03,        // 3% (严格)
                    .max_conformal_error = 1.03,
                    .max_area_deviation = 0.05,  // 5%
                    .min_feature_size = 0.1,     // 0.1mm
                    .positional_accuracy = 0.05  // 0.05mm
                };

            case Process::VINYL_CUTTING:
                return {
                    .max_stretch = 1.05,        // 5%
                    .max_conformal_error = 1.05,
                    .max_area_deviation = 0.10,  // 10%
                    .min_feature_size = 0.5,     // 0.5mm
                    .positional_accuracy = 0.2   // 0.2mm
                };

            case Process::CNC_MILLING:
                return {
                    .max_stretch = 1.08,        // 8%
                    .max_conformal_error = 1.08,
                    .max_area_deviation = 0.12,  // 12%
                    .min_feature_size = 0.5,     // 刀具半径
                    .positional_accuracy = 0.1   // 0.1mm
                };

            case Process::3D_PRINTING:
                return {
                    .max_stretch = 1.15,        // 15% (宽松)
                    .max_conformal_error = 1.15,
                    .max_area_deviation = 0.20,  // 20%
                    .min_feature_size = 0.4,     // 喷嘴直径
                    .positional_accuracy = 0.2   // 0.2mm
                };
        }
    }
};
```

### 8.2 质量检查

```cpp
struct QualityReport {
    bool passed;
    std::vector<std::string> issues;
    std::vector<std::string> warnings;

    struct Metrics {
        double max_stretch_observed;
        double max_conformal_error_observed;
        double max_area_deviation_observed;
        double min_feature_size_observed;
    } metrics;
};

QualityReport check_manufacturing_quality(
    const DistortionAnalysis& distortion,
    const PatternData& patterns,
    ManufacturingTolerance::Process process) {

    QualityReport report;
    report.passed = true;

    auto tolerance = ManufacturingTolerance::get_tolerance(process);

    // 1. 检查拉伸
    report.metrics.max_stretch_observed = distortion.statistics.max_sigma_max;
    if (report.metrics.max_stretch_observed > tolerance.max_stretch) {
        report.passed = false;
        report.issues.push_back(
            "Stretch distortion exceeds tolerance: " +
            std::to_string(report.metrics.max_stretch_observed) +
            " > " + std::to_string(tolerance.max_stretch));
    } else if (report.metrics.max_stretch_observed >
               tolerance.max_stretch * 0.9) {
        report.warnings.push_back(
            "Stretch distortion near tolerance limit: " +
            std::to_string(report.metrics.max_stretch_observed));
    }

    // 2. 检查共形误差
    report.metrics.max_conformal_error_observed =
        distortion.statistics.max_conformal_error;
    if (report.metrics.max_conformal_error_observed >
        tolerance.max_conformal_error) {
        report.passed = false;
        report.issues.push_back(
            "Conformal error exceeds tolerance: " +
            std::to_string(report.metrics.max_conformal_error_observed) +
            " > " + std::to_string(tolerance.max_conformal_error));
    }

    // 3. 检查最小特征尺寸
    double min_feature = compute_minimum_feature_size(patterns);
    report.metrics.min_feature_size_observed = min_feature;
    if (min_feature < tolerance.min_feature_size) {
        report.passed = false;
        report.issues.push_back(
            "Feature size below manufacturing capability: " +
            std::to_string(min_feature) + "mm < " +
            std::to_string(tolerance.min_feature_size) + "mm");
    }

    // 4. 生成报告摘要
    if (report.passed) {
        report.warnings.push_back(
            "All quality checks passed for " +
            process_name(process) + " process");
    }

    return report;
}
```

---

## 9. 常见陷阱与规避

### 9.1 UV归一化陷阱

**❌ 错误做法**:
```cpp
// 错误：归一化UV会丢失尺度信息
for (auto& uv : uv_coords) {
    uv /= bbox.diagonal();  // 归一化到[0,1]
}
```

**✅ 正确做法**:
```cpp
// 正确：保持mm单位
// BFF已经输出Real-Space UV，无需额外处理
// 直接使用即可
```

### 9.2 面倒置问题

**问题**: BFF展开后可能产生翻折或面倒置

**检测**:
```cpp
bool check_triangle_orientation(const Triangle2D& tri_uv) {
    // 计算有向面积
    double signed_area =
        0.5 * ((tri_uv.v1.x - tri_uv.v0.x) * (tri_uv.v2.y - tri_uv.v0.y) -
               (tri_uv.v2.x - tri_uv.v0.x) * (tri_uv.v1.y - tri_uv.v0.y));

    return signed_area > 0;  // 正向面积
}

void detect_inverted_faces(const Mesh& mesh, const UVCoordinates& uv) {
    std::vector<Face> inverted;

    for (Face f : mesh.faces()) {
        auto tri_uv = get_triangle_uv(f, uv);
        if (!check_triangle_orientation(tri_uv)) {
            inverted.push_back(f);
        }
    }

    if (!inverted.empty()) {
        std::cerr << "Warning: Found " << inverted.size()
                  << " inverted faces in UV!" << std::endl;
    }
}
```

**修复**:
```cpp
void fix_inverted_faces(UVCoordinates& uv, const std::vector<Face>& inverted) {
    for (Face f : inverted) {
        // 方法1: 翻转UV三角形
        auto vertices = get_face_vertices(f);
        std::swap(uv.coords[vertices[1]], uv.coords[vertices[2]]);

        // 方法2: 局部重解BFF (更精确但更慢)
        // ...
    }
}
```

### 9.3 跨缝漂移

**❌ 错误做法**:
```cpp
// 错误：直接在UV空间布置跨缝图案
// 会导致两侧无法对齐
PathsD pattern_uv = generate_grid_pattern(bbox);
// 如果pattern跨越缝线，映射回3D会断裂
```

**✅ 正确做法**:
```cpp
// 方法1: 分岛处理
for (const auto& island : uv.islands) {
    auto pattern_clipped = clipper.clip(pattern, island.boundary);
    // 每个岛独立映射
}

// 方法2: 3D空间定义
// 先在3D曲面上生成路径，再投影到UV
auto paths_3d = generate_geodesic_grid(mesh, geometry);
auto paths_uv = project_3d_to_uv(paths_3d, uv);
```

### 9.4 开放网格处理

**问题**: 开边界既是天然缝，不应重复切割

```cpp
void mark_open_boundaries(Mesh& mesh, SeamInfo& seams) {
    // 1. 检测开边界
    std::unordered_set<Mesh::Edge_index> boundary_edges;
    for (auto edge : mesh.edges()) {
        if (mesh.is_border(edge)) {
            boundary_edges.insert(edge);
        }
    }

    // 2. 将开边界标记为缝
    seams.edges.insert(boundary_edges.begin(), boundary_edges.end());

    // 3. 在切缝算法中降低开边界附近的新增缝权重
    for (auto edge : mesh.edges()) {
        if (is_near_boundary(edge, boundary_edges, 5)) {  // 5层邻域
            cut_weights[edge] *= 0.1;  // 大幅降低权重
        }
    }
}
```

### 9.5 浮点精度问题

```cpp
const double EPSILON = 1e-10;

bool is_point_on_edge(const Vector2& point,
                     const Vector2& edge_start,
                     const Vector2& edge_end) {
    // 错误：直接比较
    // double t = ...; return t >= 0 && t <= 1;

    // 正确：使用epsilon容差
    double t = compute_edge_parameter(point, edge_start, edge_end);
    return (t >= -EPSILON) && (t <= 1.0 + EPSILON);
}

bool are_triangles_adjacent(const Triangle& t1, const Triangle& t2) {
    // 检查共享顶点时使用epsilon
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            if ((t1.vertices[i] - t2.vertices[j]).norm() < EPSILON) {
                // 共享顶点
            }
        }
    }
}
```

---

## 10. 验证与校准流程

### 10.1 圆柱/圆锥测试

**目的**: 验证周长和斜高的绝对量纲

```cpp
void test_cylinder_unwrap() {
    // 1. 生成圆柱 (半径R=10mm, 高度H=50mm)
    double R = 10.0, H = 50.0;
    auto mesh = generate_cylinder(R, H, 32);  // 32个周向分辨率

    // 2. UV展开
    auto uv = unfold_cylinder(mesh);

    // 3. 验证
    double expected_width = 2 * M_PI * R;  // 周长 ≈ 62.83mm
    double expected_height = H;             // 高度 = 50mm

    auto bbox = compute_uv_bbox(uv);
    double actual_width = bbox.width();
    double actual_height = bbox.height();

    double width_error = std::abs(actual_width - expected_width) / expected_width;
    double height_error = std::abs(actual_height - expected_height) / expected_height;

    std::cout << "Cylinder Test:" << std::endl;
    std::cout << "  Expected: " << expected_width << " × " << expected_height << " mm" << std::endl;
    std::cout << "  Actual:   " << actual_width << " × " << actual_height << " mm" << std::endl;
    std::cout << "  Error:    " << (width_error * 100) << "% × "
              << (height_error * 100) << "%" << std::endl;

    ASSERT_LT(width_error, 0.01);   // 误差 < 1%
    ASSERT_LT(height_error, 0.01);
}
```

### 10.2 打印校准流程

**步骤1: 生成校准板**
```cpp
void generate_calibration_plate(const std::string& output_svg) {
    // 100×100mm标准网格
    const double size = 100.0;  // mm
    const double grid_spacing = 10.0;  // mm

    std::ofstream svg(output_svg);
    svg << "<?xml version=\"1.0\"?>\n";
    svg << "<svg xmlns=\"http://www.w3.org/2000/svg\" ";
    svg << "viewBox=\"0 0 " << size << " " << size << "\" ";
    svg << "width=\"" << size << "mm\" height=\"" << size << "mm\">\n";

    // 绘制网格
    for (double x = 0; x <= size; x += grid_spacing) {
        svg << "<line x1=\"" << x << "\" y1=\"0\" ";
        svg << "x2=\"" << x << "\" y2=\"" << size << "\" ";
        svg << "stroke=\"black\" stroke-width=\"0.1\"/>\n";
    }
    for (double y = 0; y <= size; y += grid_spacing) {
        svg << "<line x1=\"0\" y1=\"" << y << "\" ";
        svg << "x2=\"" << size << "\" y2=\"" << y << "\" ";
        svg << "stroke=\"black\" stroke-width=\"0.1\"/>\n";
    }

    // 添加定位靶标
    svg << "<circle cx=\"10\" cy=\"10\" r=\"5\" ";
    svg << "stroke=\"black\" fill=\"none\" stroke-width=\"0.2\"/>\n";
    svg << "<circle cx=\"90\" cy=\"10\" r=\"5\" ";
    svg << "stroke=\"black\" fill=\"none\" stroke-width=\"0.2\"/>\n";
    svg << "<circle cx=\"10\" cy=\"90\" r=\"5\" ";
    svg << "stroke=\"black\" fill=\"none\" stroke-width=\"0.2\"/>\n";
    svg << "<circle cx=\"90\" cy=\"90\" r=\"5\" ";
    svg << "stroke=\"black\" fill=\"none\" stroke-width=\"0.2\"/>\n";

    // 标注尺寸
    svg << "<text x=\"50\" y=\"5\" text-anchor=\"middle\" ";
    svg << "font-size=\"3\">100mm</text>\n";

    svg << "</svg>\n";
}
```

**步骤2: 测量和计算补偿**
```cpp
struct CalibrationMeasurement {
    double measured_width_mm;
    double measured_height_mm;
    double expected_width_mm = 100.0;
    double expected_height_mm = 100.0;

    // 计算补偿系数
    CalibrationResult compute_compensation() const {
        CalibrationResult result;

        // 缩放补偿
        result.scale_x = expected_width_mm / measured_width_mm;
        result.scale_y = expected_height_mm / measured_height_mm;

        // 剪切补偿 (如果测量到的不是矩形)
        // result.shear = ...;

        // 旋转补偿
        // result.rotation = ...;

        std::cout << "Calibration Result:" << std::endl;
        std::cout << "  Scale X: " << result.scale_x << std::endl;
        std::cout << "  Scale Y: " << result.scale_y << std::endl;

        return result;
    }
};

// 应用校准
void apply_calibration(UVCoordinates& uv,
                       const CalibrationResult& calib) {
    Eigen::Matrix2d transform;
    transform << calib.scale_x, calib.shear,
                 0, calib.scale_y;

    for (auto& coord : uv.coords) {
        coord = transform * coord;
    }
}
```

**步骤3: 迭代验证**
```cpp
void iterative_calibration() {
    RSConfig config;

    // 第1次打印
    generate_calibration_plate("calib_v1.svg");
    std::cout << "Print calib_v1.svg and measure..." << std::endl;

    CalibrationMeasurement meas1;
    std::cout << "Enter measured width (mm): ";
    std::cin >> meas1.measured_width_mm;
    std::cout << "Enter measured height (mm): ";
    std::cin >> meas1.measured_height_mm;

    auto calib1 = meas1.compute_compensation();

    // 应用补偿到配置
    config.scale_x = calib1.scale_x;
    config.scale_y = calib1.scale_y;

    // 第2次验证打印
    UVCoordinates uv_calib = generate_test_grid(100, 100);
    apply_calibration(uv_calib, calib1);
    export_svg("calib_v2.svg", uv_calib);

    std::cout << "Print calib_v2.svg and verify..." << std::endl;
    // 重复测量，误差应<1%
}
```

### 10.3 复杂自由曲面测试

```cpp
void test_complex_surface() {
    // 1. 加载复杂模型 (如Stanford Bunny)
    auto mesh = load_mesh("bunny.obj");

    // 2. 完整流程
    auto result = run_unfold3d_mini(mesh, default_config);

    // 3. 检查失真分布
    std::cout << "Distortion Statistics:" << std::endl;
    std::cout << "  Mean σ_max: " << result.distortion.mean_sigma_max << std::endl;
    std::cout << "  Std σ_max: " << result.distortion.std_sigma_max << std::endl;
    std::cout << "  Max σ_max: " << result.distortion.max_sigma_max << std::endl;
    std::cout << "  95% σ_max: " << result.distortion.percentile_95_sigma_max << std::endl;
    std::cout << "  Pass rate: " << (result.distortion.pass_rate * 100) << "%" << std::endl;

    // 4. 可视化热力图
    visualize_distortion_heatmap(mesh, result.distortion);

    // 5. 检查迭代收敛
    if (result.num_iterations > 1) {
        std::cout << "Converged after " << result.num_iterations
                  << " iterations" << std::endl;

        // 绘制收敛曲线
        plot_convergence_curve(result.iteration_history);
    }
}
```

---

## 11. 性能优化策略

### 11.1 大规模网格优化

```cpp
class LargeScaleOptimizer {
public:
    // 百万级三角优化策略
    UVResult process_large_mesh(Mesh& mesh, const RSConfig& config) {
        size_t num_faces = mesh.num_faces();

        if (num_faces > 100000) {
            std::cout << "Large mesh detected (" << num_faces
                      << " faces), applying optimizations..." << std::endl;

            // 1. 简化预处理
            if (config.enable_simplification) {
                double error_threshold = config.target_edge_len * 0.1;
                mesh = simplify_mesh(mesh, error_threshold);
                std::cout << "Simplified to " << mesh.num_faces()
                          << " faces" << std::endl;
            }

            // 2. 分层处理
            if (num_faces > 500000) {
                return process_in_batches(mesh, config);
            }
        }

        // 正常处理
        return process_normal(mesh, config);
    }

private:
    UVResult process_in_batches(const Mesh& mesh, const RSConfig& config) {
        // 1. 分割网格为多个批次
        auto batches = partition_mesh(mesh, 100000);  // 每批10万面

        // 2. 并行处理每个批次
        std::vector<UVResult> batch_results(batches.size());

        #pragma omp parallel for
        for (size_t i = 0; i < batches.size(); ++i) {
            batch_results[i] = process_batch(batches[i], config);
        }

        // 3. 合并结果
        return merge_uv_results(batch_results);
    }

    Mesh simplify_mesh(const Mesh& mesh, double error_threshold) {
        // 使用edge collapse简化
        CGAL::Polygon_mesh_processing::EdgeCollapseSimplifier simplifier(mesh);
        simplifier.set_stop_predicate(
            CGAL::SMS::LindstromTurk_cost<Mesh>(),
            CGAL::SMS::LindstromTurk_placement<Mesh>(),
            error_threshold
        );

        return simplifier.simplify();
    }
};
```

### 11.2 多线程并行化

```cpp
class ParallelProcessor {
public:
    void set_num_threads(int n) {
        if (n == 0) {
            n = std::thread::hardware_concurrency();
        }
        omp_set_num_threads(n);
    }

    // 按岛并行处理
    UVResult process_islands_parallel(
        const std::vector<IslandMesh>& islands,
        const RSConfig& config) {

        std::vector<IslandUV> results(islands.size());

        #pragma omp parallel for schedule(dynamic)
        for (size_t i = 0; i < islands.size(); ++i) {
            results[i] = parametrize_island(islands[i], config);
        }

        return merge_island_uvs(results);
    }

    // 失真分析并行化
    DistortionAnalysis analyze_distortion_parallel(
        const Mesh& mesh,
        const Geometry& geometry,
        const UVMapping& uv) {

        size_t num_faces = mesh.num_faces();
        std::vector<PerFaceMetrics> metrics(num_faces);

        #pragma omp parallel for
        for (size_t i = 0; i < num_faces; ++i) {
            Face f(i);
            auto tri_3d = get_triangle_3d(f, geometry);
            auto tri_uv = get_triangle_uv(f, uv);

            auto I = compute_jacobian_2x2(tri_3d, tri_uv);
            auto stretch = compute_stretch(I);

            metrics[i].sigma_min = stretch.sigma_min;
            metrics[i].sigma_max = stretch.sigma_max;
            metrics[i].conformal_error = stretch.sigma_max / stretch.sigma_min;
            metrics[i].area_ratio = compute_area_distortion(tri_3d, tri_uv);
        }

        return DistortionAnalysis{metrics, compute_statistics(metrics)};
    }
};
```

### 11.3 内存管理

```cpp
class MemoryManager {
public:
    // 按岛分块处理，及时释放内存
    UVResult process_with_memory_limit(
        const Mesh& mesh,
        const RSConfig& config) {

        UVResult result;

        for (const auto& island : extract_islands(mesh)) {
            // 1. 处理当前岛
            auto island_uv = parametrize_island(island, config);

            // 2. 保存结果
            result.islands_uv.push_back(std::move(island_uv));

            // 3. 释放临时数据
            // BFF线性系统矩阵已自动释放

            // 4. 检查内存使用
            size_t mem_used = get_memory_usage();
            if (mem_used > config.max_memory_mb * 1024 * 1024) {
                std::cerr << "Warning: Memory usage " << (mem_used / 1024 / 1024)
                          << "MB exceeds limit" << std::endl;
                // 强制垃圾回收或切换到磁盘缓存
            }
        }

        return result;
    }

private:
    size_t get_memory_usage() {
        // Linux: /proc/self/status
        // Windows: GetProcessMemoryInfo
        // macOS: task_info
        #ifdef __linux__
        std::ifstream status("/proc/self/status");
        std::string line;
        while (std::getline(status, line)) {
            if (line.substr(0, 6) == "VmRSS:") {
                size_t mem_kb = std::stoul(line.substr(6));
                return mem_kb * 1024;
            }
        }
        #endif
        return 0;
    }
};
```

### 11.4 性能基准

```cpp
struct PerformanceBenchmark {
    std::string model_name;
    size_t num_faces;

    double preprocessing_time;
    double cutting_time;
    double parametrization_time;
    double distortion_analysis_time;
    double pattern_filling_time;
    double mapping_3d_time;
    double total_time;

    size_t peak_memory_mb;

    void print() const {
        std::cout << "\nPerformance Benchmark: " << model_name << std::endl;
        std::cout << "  Faces: " << num_faces << std::endl;
        std::cout << "  Preprocessing: " << preprocessing_time << "s" << std::endl;
        std::cout << "  Cutting: " << cutting_time << "s" << std::endl;
        std::cout << "  Parametrization: " << parametrization_time << "s" << std::endl;
        std::cout << "  Distortion Analysis: " << distortion_analysis_time << "s" << std::endl;
        std::cout << "  Pattern Filling: " << pattern_filling_time << "s" << std::endl;
        std::cout << "  3D Mapping: " << mapping_3d_time << "s" << std::endl;
        std::cout << "  Total: " << total_time << "s" << std::endl;
        std::cout << "  Peak Memory: " << peak_memory_mb << "MB" << std::endl;
    }
};

void run_benchmark_suite() {
    std::vector<std::string> test_models = {
        "sphere_1k.obj",    // 1k面片
        "bunny_10k.obj",    // 10k面片
        "dragon_100k.obj"   // 100k面片
    };

    for (const auto& model : test_models) {
        PerformanceBenchmark bench;
        bench.model_name = model;

        auto mesh = load_mesh(model);
        bench.num_faces = mesh.num_faces();

        // 测量各阶段时间
        Timer timer;

        timer.start();
        auto processed = preprocess_mesh(mesh, config);
        bench.preprocessing_time = timer.elapsed();

        timer.start();
        auto cuts = compute_cuts(processed, config);
        bench.cutting_time = timer.elapsed();

        timer.start();
        auto uv = parametrize_bff(processed, cuts, config);
        bench.parametrization_time = timer.elapsed();

        timer.start();
        auto distortion = analyze_distortion(processed, uv);
        bench.distortion_analysis_time = timer.elapsed();

        timer.start();
        auto patterns = fill_patterns(uv, config);
        bench.pattern_filling_time = timer.elapsed();

        timer.start();
        auto curves_3d = map_to_3d(patterns, uv, processed);
        bench.mapping_3d_time = timer.elapsed();

        bench.total_time = bench.preprocessing_time +
                          bench.cutting_time +
                          bench.parametrization_time +
                          bench.distortion_analysis_time +
                          bench.pattern_filling_time +
                          bench.mapping_3d_time;

        bench.peak_memory_mb = get_peak_memory_usage() / 1024 / 1024;

        bench.print();
    }
}
```

**目标性能基准**:

| 模型规模 | 预处理 | 切割 | UV展开 | 失真分析 | 图案映射 | 总时间 | 内存 |
|---------|--------|------|--------|----------|----------|--------|------|
| 1k面片   | <0.1s | <0.5s | <0.2s | <0.1s | <0.3s | <1.5s | <100MB |
| 10k面片  | <0.5s | <2s   | <1s   | <0.5s | <1s   | <5s   | <500MB |
| 100k面片 | <5s   | <20s  | <10s  | <5s   | <10s  | <50s  | <2GB   |

---

## 12. 完整代码框架

### 12.1 主程序入口

```cpp
#include "real_space_config.h"
#include "mesh_processor.h"
#include "variational_cutter.h"
#include "bff_parametrizer.h"
#include "distortion_analyzer.h"
#include "pattern_filler.h"
#include "uv_to_3d_mapper.h"

int main(int argc, char** argv) {
    // 1. 解析命令行参数
    CLI::App app{"Mini-Unfold3D: Real-Space UV Unwrapping Tool"};

    std::string input_file;
    std::string output_prefix = "output";
    std::string config_file = "config.json";
    std::string pattern_file;

    app.add_option("-i,--input", input_file, "Input mesh file (OBJ/PLY/STL)")
       ->required();
    app.add_option("-o,--output", output_prefix, "Output file prefix");
    app.add_option("-c,--config", config_file, "Configuration file (JSON)");
    app.add_option("-p,--pattern", pattern_file, "Pattern file (SVG/DXF)");

    CLI11_PARSE(app, argc, argv);

    // 2. 加载配置
    RSConfig config = RSConfig::load_from_json(config_file);

    std::string error_msg;
    if (!config.validate(error_msg)) {
        std::cerr << "Configuration error: " << error_msg << std::endl;
        return 1;
    }

    std::cout << "=== Mini-Unfold3D Real-Space UV Unwrapping ===" << std::endl;
    std::cout << "Input: " << input_file << std::endl;
    std::cout << "Unit: " << config.unit_name << std::endl;
    std::cout << "Target stretch: " << config.stretch_thresh << std::endl;

    try {
        // 3. 加载和预处理网格
        std::cout << "\n[1/6] Loading and preprocessing mesh..." << std::endl;
        MeshProcessor processor;
        auto mesh = processor.load_and_preprocess(input_file, config);
        std::cout << "  Loaded " << mesh->num_faces() << " faces" << std::endl;

        // 4. 自动切缝
        std::cout << "\n[2/6] Computing optimal cuts..." << std::endl;
        VariationalCutter cutter;
        auto cuts = cutter.compute_optimal_cuts(*mesh, config);
        std::cout << "  Generated " << cuts.seams.size() << " seams" << std::endl;
        std::cout << "  Created " << cuts.islands.size() << " UV islands" << std::endl;

        // 5. 迭代优化展开
        std::cout << "\n[3/6] Parametrizing with BFF..." << std::endl;
        IterativeUVOptimizer optimizer;
        IterativeUVOptimizer::IterationConfig iter_config;
        iter_config.max_iterations = config.max_iterations;
        iter_config.target_sigma_max = config.stretch_thresh;
        iter_config.auto_add_cuts = config.auto_refine_cuts;

        auto iter_result = optimizer.optimize(*mesh, geometry, iter_config);

        if (iter_result.converged) {
            std::cout << "  Converged after " << iter_result.num_iterations
                      << " iterations" << std::endl;
        } else {
            std::cout << "  Did not fully converge, best result after "
                      << iter_result.num_iterations << " iterations" << std::endl;
        }

        auto& final_uv = iter_result.final_uv;
        auto& final_distortion = iter_result.history.back();

        // 6. 失真可视化
        std::cout << "\n[4/6] Analyzing distortion..." << std::endl;
        std::cout << "  Max σ_max: " << final_distortion.statistics.max_sigma_max << std::endl;
        std::cout << "  95% σ_max: " << final_distortion.statistics.percentile_95_sigma_max << std::endl;
        std::cout << "  Pass rate: " << (final_distortion.statistics.pass_rate * 100) << "%" << std::endl;

        // 生成失真热力图
        std::string distortion_img = output_prefix + "_distortion.png";
        visualize_distortion_heatmap(*mesh, final_distortion, distortion_img);
        std::cout << "  Saved distortion heatmap to " << distortion_img << std::endl;

        // 7. UV空间图案填充
        std::cout << "\n[5/6] Generating patterns..." << std::endl;
        PatternFiller filler;
        PatternData patterns;

        if (!pattern_file.empty()) {
            patterns = filler.fill_with_pattern_file(
                final_uv, pattern_file, config);
        } else {
            patterns = filler.fill_with_default_pattern(
                final_uv, config);
        }

        std::cout << "  Generated " << patterns.num_paths << " paths" << std::endl;
        std::cout << "  Total length: " << patterns.total_length << "mm" << std::endl;

        // 8. 回映射到3D
        std::cout << "\n[6/6] Mapping to 3D..." << std::endl;
        UVTo3DMapper mapper;
        auto curves_3d = mapper.map_patterns_to_3d(
            patterns, final_uv, *mesh, geometry);

        std::cout << "  Mapped " << curves_3d.curves.size() << " 3D curves" << std::endl;

        // 9. 导出所有结果
        std::cout << "\nExporting results..." << std::endl;

        // UV网格 (OBJ)
        if (config.export_uv_obj) {
            std::string uv_obj = output_prefix + "_uv.obj";
            export_uv_obj(uv_obj, *mesh, final_uv, config);
            std::cout << "  " << uv_obj << std::endl;
        }

        // UV矢量图 (SVG 1:1)
        if (config.export_svg) {
            std::string uv_svg = output_prefix + "_uv.svg";
            export_svg_real_scale(uv_svg, final_uv, patterns, config);
            std::cout << "  " << uv_svg << std::endl;
        }

        // 3D曲线 (STEP)
        if (config.export_step) {
            std::string curves_step = output_prefix + "_curves.step";
            export_curves_step(curves_step, curves_3d);
            std::cout << "  " << curves_step << std::endl;
        }

        // JSON报告
        if (config.export_report) {
            std::string report_json = output_prefix + "_report.json";
            export_json_report(report_json, *mesh, final_uv,
                             final_distortion, patterns, curves_3d, config);
            std::cout << "  " << report_json << std::endl;
        }

        // 10. 质量检查
        std::cout << "\nQuality Control:" << std::endl;
        auto quality = check_manufacturing_quality(
            final_distortion, patterns,
            ManufacturingTolerance::Process::LASER_ENGRAVING);

        if (quality.passed) {
            std::cout << "  ✓ PASSED" << std::endl;
        } else {
            std::cout << "  ✗ FAILED" << std::endl;
            for (const auto& issue : quality.issues) {
                std::cout << "    - " << issue << std::endl;
            }
        }

        for (const auto& warning : quality.warnings) {
            std::cout << "  ⚠ " << warning << std::endl;
        }

        std::cout << "\nProcessing complete!" << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
```

### 12.2 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)
project(MiniUnfold3D VERSION 1.0)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找依赖
find_package(CGAL REQUIRED)
find_package(Eigen3 REQUIRED)
find_package(OpenMP REQUIRED)

# geometry-central (submodule)
add_subdirectory(deps/geometry-central)

# BFF (submodule)
add_subdirectory(deps/boundary-first-flattening)

# Clipper2 (submodule)
add_subdirectory(deps/clipper2)

# CLI11 (header-only)
include_directories(deps/CLI11/include)

# nlohmann/json (header-only)
include_directories(deps/json/include)

# 源文件
set(SOURCES
    src/main.cpp
    src/real_space_config.cpp
    src/mesh_processor.cpp
    src/variational_cutter.cpp
    src/bff_parametrizer.cpp
    src/distortion_analyzer.cpp
    src/pattern_filler.cpp
    src/uv_to_3d_mapper.cpp
    src/exporter.cpp
    src/quality_control.cpp
)

# 可执行文件
add_executable(unfold3d ${SOURCES})

target_include_directories(unfold3d PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(unfold3d
    CGAL::CGAL
    Eigen3::Eigen
    geometry-central
    bff
    Clipper2
    OpenMP::OpenMP_CXX
)

# 编译选项
if(MSVC)
    target_compile_options(unfold3d PRIVATE /W4 /O2)
else()
    target_compile_options(unfold3d PRIVATE -Wall -Wextra -O3)
endif()

# 安装
install(TARGETS unfold3d DESTINATION bin)
install(FILES config_template.json DESTINATION share/unfold3d)
```

---

## 总结

本文档提供了**Real-Space UV展开**的完整工程化实施指南，核心要点：

1. **单位闭环**: 全链路mm单位，杜绝归一化
2. **失真评估**: σ_max/QC/面积比三重指标
3. **迭代优化**: 失真驱动的自动返修
4. **制造容差**: 按工艺定义PASS/FAIL标准
5. **跨缝处理**: 重心映射+测地线修边
6. **校准流程**: 100×100mm标准板验证
7. **性能优化**: 多线程+内存管理+分批处理

配合《MINI_UNFOLD3D_TECHNICAL_ROADMAP.md》使用，可实现从学术原型到工程产品的完整落地。