# Miniç‰ˆUnfold3D DemoæŠ€æœ¯è·¯çº¿ä¸å®æ–½è®¡åˆ’
**ç‰ˆæœ¬**: 1.0
**æ—¥æœŸ**: 2025-01-30
**é¡¹ç›®ä»£å·**: Mini-Unfold3D

---

## ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
2. [ç³»ç»Ÿæ¶æ„è®¾è®¡](#2-ç³»ç»Ÿæ¶æ„è®¾è®¡)
3. [æ ¸å¿ƒæ¨¡å—è¯¦ç»†è¯´æ˜](#3-æ ¸å¿ƒæ¨¡å—è¯¦ç»†è¯´æ˜)
4. [ç®—æ³•åŸç†å’Œå®ç°ç»†èŠ‚](#4-ç®—æ³•åŸç†å’Œå®ç°ç»†èŠ‚)
5. [å®æ–½è®¡åˆ’å’Œé‡Œç¨‹ç¢‘](#5-å®æ–½è®¡åˆ’å’Œé‡Œç¨‹ç¢‘)
6. [é£é™©è¯„ä¼°å’Œåº”å¯¹ç­–ç•¥](#6-é£é™©è¯„ä¼°å’Œåº”å¯¹ç­–ç•¥)
7. [æŠ€æœ¯æ ˆå’Œä¾èµ–](#7-æŠ€æœ¯æ ˆå’Œä¾èµ–)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®èƒŒæ™¯

Unfold3Dæ˜¯ä¸šç•Œé¢†å…ˆçš„UVå±•å¼€å·¥å…·ï¼Œå¹¿æ³›åº”ç”¨äºæ¸¸æˆã€å½±è§†å’Œå·¥ä¸šè®¾è®¡é¢†åŸŸã€‚æœ¬é¡¹ç›®æ—¨åœ¨å®ç°ä¸€ä¸ªMiniç‰ˆçš„Unfold3Dæ¼”ç¤ºç³»ç»Ÿï¼Œå±•ç¤ºä»3Dæ¨¡å‹åˆ°UVå±•å¼€ã€å¤±çœŸåˆ†æã€å›¾æ¡ˆå¡«å……åˆ°3Då›æ˜ å°„çš„å®Œæ•´å·¥ä½œæµç¨‹ã€‚

### 1.2 é¡¹ç›®ç›®æ ‡

**ä¸»è¦ç›®æ ‡**ï¼š
- å®ç°è‡ªåŠ¨åŒ–çš„UVå±•å¼€å·¥ä½œæµç¨‹
- æä¾›UVå¤±çœŸçš„å¯è§†åŒ–åˆ†æå·¥å…·
- æ”¯æŒUVç©ºé—´å›¾æ¡ˆç”Ÿæˆå’Œ3Då›æ˜ å°„
- æ„å»ºå¯æ‰©å±•çš„æ¨¡å—åŒ–æ¶æ„

**æŠ€æœ¯ç›®æ ‡**ï¼š
- é›†æˆå­¦æœ¯ç•Œæœ€æ–°çš„å˜åˆ†åˆ‡å‰²ç®—æ³•
- å®ç°é«˜è´¨é‡çš„BFFå‚æ•°åŒ–
- å¼€å‘å®æ—¶çš„å¤±çœŸåº¦å¯è§†åŒ–
- æä¾›ç¨³å®šçš„UVåˆ°3Dæ˜ å°„ç®—æ³•

### 1.3 åº”ç”¨åœºæ™¯

- **çº¹ç†è´´å›¾åˆ¶ä½œ**ï¼šä¸º3Dæ¨¡å‹ç”Ÿæˆé«˜è´¨é‡UVåæ ‡
- **å›¾æ¡ˆè®¾è®¡**ï¼šåœ¨3Dè¡¨é¢åº”ç”¨å¤æ‚çš„è£…é¥°å›¾æ¡ˆ
- **æ•°å­—åˆ¶é€ **ï¼šä¸º3Dæ‰“å°å’ŒCNCåŠ å·¥ç”Ÿæˆåˆ€å…·è·¯å¾„
- **ç§‘ç ”æ•™å­¦**ï¼šä½œä¸ºè®¡ç®—å‡ ä½•å’Œæ•°å­—å‡ ä½•å¤„ç†çš„æ•™å­¦å·¥å…·

### 1.4 é¢„æœŸæˆæœ

- å®Œæ•´çš„UVå±•å¼€å·¥ä½œæµç¨‹å®ç°
- æ”¯æŒå¤šç§ç½‘æ ¼æ ¼å¼è¾“å…¥è¾“å‡º
- å®æ—¶å¤±çœŸåº¦å¯è§†åŒ–ç³»ç»Ÿ
- ä¸°å¯Œçš„å›¾æ¡ˆç”Ÿæˆå’Œæ˜ å°„åŠŸèƒ½
- è¯¦ç»†çš„æŠ€æœ¯æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç 

---

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ·ç•Œé¢å±‚ (UI Layer)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ImGuiç•Œé¢   â”‚  â”‚  OpenGLæ¸²æŸ“  â”‚  â”‚  äº¤äº’æ§åˆ¶   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åº”ç”¨é€»è¾‘å±‚ (Application)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           UVå±•å¼€å·¥ä½œæµç¨‹ç®¡ç†å™¨                     â”‚  â”‚
â”‚  â”‚  (Workflow Manager & Pipeline Controller)        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ç®—æ³•æ¨¡å—å±‚ (Algorithm Layer)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ç½‘æ ¼é¢„å¤„ç†â”‚  â”‚å˜åˆ†åˆ‡å‰²  â”‚  â”‚ BFFå±•å¼€  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚å¤±çœŸåˆ†æ  â”‚  â”‚å›¾æ¡ˆå¡«å……  â”‚  â”‚ 3Dæ˜ å°„   â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ ¸å¿ƒåº“å±‚ (Core Libraries)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   CGAL   â”‚  â”‚geometry-centralâ”‚  â”‚ Clipper2 â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Eigen3  â”‚  â”‚   OpenGL      â”‚  â”‚  ImGui   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ•°æ®æµè®¾è®¡

```
è¾“å…¥3Dæ¨¡å‹ (.obj/.ply/.stl)
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   1. ç½‘æ ¼é¢„å¤„ç†      â”‚
â”‚  - æµå½¢åŒ–æ£€æŸ¥        â”‚
â”‚  - ç­‰å„å‘æ€§é‡ç½‘æ ¼åŒ–  â”‚
â”‚  - æ‹“æ‰‘åˆ†æ          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
    é¢„å¤„ç†ç½‘æ ¼
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   2. å˜åˆ†åˆ‡å‰²        â”‚
â”‚  - Yamabeèƒ½é‡ä¼˜åŒ–    â”‚
â”‚  - å½¢çŠ¶å¯¼æ•°è®¡ç®—      â”‚
â”‚  - æ°´å¹³é›†æ¼”åŒ–        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
    å¸¦åˆ‡ç¼ç½‘æ ¼
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   3. BFF UVå±•å¼€      â”‚
â”‚  - é”¥ç‚¹æ£€æµ‹          â”‚
â”‚  - å…±å½¢æ˜ å°„          â”‚
â”‚  - è¾¹ç•Œä¼˜åŒ–          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
    UVå‚æ•°åŒ–ç»“æœ
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. å¤±çœŸåˆ†æå¯è§†åŒ–   â”‚
â”‚  - è§’åº¦å¤±çœŸè®¡ç®—      â”‚
â”‚  - é¢ç§¯å¤±çœŸè®¡ç®—      â”‚
â”‚  - æ‹‰ä¼¸å¤±çœŸè®¡ç®—      â”‚
â”‚  - é¢œè‰²ç¼–ç æ˜ å°„      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
    å¤±çœŸåº¦é‡æ•°æ®
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. UVç©ºé—´å›¾æ¡ˆç”Ÿæˆ   â”‚
â”‚  - å›¾æ¡ˆç±»å‹é€‰æ‹©      â”‚
â”‚  - Clipper2å¸ƒå°”è¿ç®—  â”‚
â”‚  - è¾¹ç•Œè£å‰ª          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
    UVç©ºé—´å›¾æ¡ˆè·¯å¾„
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. 3Då›æ˜ å°„         â”‚
â”‚  - é‡å¿ƒåæ ‡è®¡ç®—      â”‚
â”‚  - è·¨ä¸‰è§’å½¢è·¯å¾„å¤„ç†  â”‚
â”‚  - æµ‹åœ°çº¿ç”Ÿæˆ        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
    3Dç©ºé—´å›¾æ¡ˆ
        â†“
è¾“å‡ºç»“æœ (.obj + çº¹ç† + è·¯å¾„)
```

### 2.3 æ¨¡å—é—´æ¥å£è®¾è®¡

```cpp
// ç»Ÿä¸€çš„ç½‘æ ¼æ•°æ®ç»“æ„
struct UnifiedMesh {
    std::shared_ptr<HalfedgeMesh> mesh;
    std::shared_ptr<VertexPositionGeometry> geometry;
    VertexData<Vector2> uvCoords;
    FaceData<int> chartIDs;  // UVå›¾è¡¨æ ‡è¯†
};

// å·¥ä½œæµç¨‹æ¥å£
class IWorkflowStep {
public:
    virtual bool process(UnifiedMesh& mesh) = 0;
    virtual std::string getName() const = 0;
    virtual void setParameters(const json& params) = 0;
    virtual json getResults() const = 0;
};

// ç®¡é“æ§åˆ¶å™¨
class PipelineController {
    std::vector<std::unique_ptr<IWorkflowStep>> steps;
    UnifiedMesh currentMesh;

public:
    void addStep(std::unique_ptr<IWorkflowStep> step);
    bool executeAll();
    bool executeStep(size_t index);
    void saveCheckpoint(const std::string& filename);
    void loadCheckpoint(const std::string& filename);
};
```

---

## 3. æ ¸å¿ƒæ¨¡å—è¯¦ç»†è¯´æ˜

### 3.1 ç½‘æ ¼é¢„å¤„ç†æ¨¡å— (MeshProcessor)

**åŠŸèƒ½èŒè´£**ï¼š
- ç½‘æ ¼æµå½¢åŒ–å’Œæ‹“æ‰‘ä¿®å¤
- ç­‰å„å‘æ€§é‡ç½‘æ ¼åŒ–
- ç½‘æ ¼è´¨é‡è¯„ä¼°
- è¾¹ç•Œå’Œç‰¹å¾æ£€æµ‹

**å…³é”®æ¥å£**ï¼š
```cpp
class MeshProcessor {
public:
    // ç½‘æ ¼åŠ è½½å’ŒéªŒè¯
    bool loadMesh(const std::string& filename);
    bool validateManifold();

    // é‡ç½‘æ ¼åŒ–
    void isotropicRemeshing(
        double targetEdgeLength,
        int iterations,
        bool projectToOriginal);

    // æ‹“æ‰‘æ“ä½œ
    void fillHoles();
    void removeIsolatedVertices();
    void fixNonManifoldEdges();

    // è´¨é‡åº¦é‡
    struct QualityMetrics {
        double minAngle;
        double maxAngle;
        double avgEdgeLength;
        double aspectRatio;
    };
    QualityMetrics computeQuality();

private:
    std::unique_ptr<HalfedgeMesh> mesh;
    std::unique_ptr<VertexPositionGeometry> geometry;
};
```

### 3.2 å˜åˆ†åˆ‡å‰²æ¨¡å— (VariationalCutter)

**åŠŸèƒ½èŒè´£**ï¼š
- åŸºäºYamabeæ–¹ç¨‹çš„æœ€ä¼˜åˆ‡ç¼ç”Ÿæˆ
- æ°´å¹³é›†æ–¹æ³•çš„åˆ‡å‰²è¾¹ç•Œæ¼”åŒ–
- èƒ½é‡å‡½æ•°ä¼˜åŒ–
- åˆ‡ç¼åº”ç”¨åˆ°ç½‘æ ¼

**å…³é”®æ¥å£**ï¼š
```cpp
class VariationalCutter {
public:
    struct CutParameters {
        double lengthWeight = 1.0;      // é•¿åº¦æ­£åˆ™åŒ–
        double distortionWeight = 3.0;  // Henckyå¤±çœŸæƒé‡
        double visibilityWeight = 0.5;  // å¯è§æ€§æƒé‡
        int maxIterations = 300;
        double convergenceTol = 1e-6;
    };

    // åˆ‡ç¼è®¡ç®—
    struct CutResult {
        std::vector<std::vector<Edge>> cutPaths;
        double finalEnergy;
        int iterationsUsed;
    };

    CutResult computeOptimalCuts(const CutParameters& params);

    // åº”ç”¨åˆ‡ç¼
    std::unique_ptr<HalfedgeMesh> applyCutsToMesh(const CutResult& cuts);

private:
    // èƒ½é‡è®¡ç®—
    double computeYamabeEnergy();
    Vector<double> computeShapeDerivative();

    // æ°´å¹³é›†æ¼”åŒ–
    void evolveLevelSet(double stepSize);
    void reinitializeLevelSet();
};
```

### 3.3 çº¹ç†æ˜ å°„æ¨¡å— (TextureMapper)

**åŠŸèƒ½èŒè´£**ï¼š
- BFF (Boundary First Flattening) ç®—æ³•å®ç°
- é”¥ç‚¹æ£€æµ‹å’Œä¼˜åŒ–
- UVåæ ‡ç”Ÿæˆ
- å›¾è¡¨æ‰“åŒ…

**å…³é”®æ¥å£**ï¼š
```cpp
class TextureMapper {
public:
    struct MappingParameters {
        bool autoDetectCones = true;
        double coneAngleThreshold = M_PI / 6;
        bool minimizeDistortion = true;
        double packingMargin = 0.01;
    };

    struct UVMapping {
        VertexData<Vector2> uvCoords;
        FaceData<int> chartIDs;
        std::vector<double> coneAngles;
        double totalDistortion;
    };

    std::optional<UVMapping> computeUVMapping(
        const MappingParameters& params);

    // å¯¼å‡ºåŠŸèƒ½
    void exportUVMesh(const std::string& filename,
                     const UVMapping& mapping);
    void exportUVLayout(const std::string& filename,
                       const UVMapping& mapping);

private:
    // BFFæ ¸å¿ƒç®—æ³•
    void computeBoundaryFirstFlattening();
    void detectConeVertices();
    void optimizeConeConfiguration();
};
```

### 3.4 å¤±çœŸåˆ†ææ¨¡å— (UVDistortionAnalyzer) ğŸ†•

**åŠŸèƒ½èŒè´£**ï¼š
- è®¡ç®—å„ç§å¤±çœŸåº¦é‡
- ç”Ÿæˆå¤±çœŸçƒ­åŠ›å›¾
- ç»Ÿè®¡å¤±çœŸåˆ†å¸ƒ
- å¤±çœŸçº¹ç†ç”Ÿæˆ

**å…³é”®æ¥å£**ï¼š
```cpp
class UVDistortionAnalyzer {
public:
    struct DistortionMetrics {
        // æ¯é¢å¤±çœŸ
        FaceData<double> angleDistortion;   // è§’åº¦å¤±çœŸ
        FaceData<double> areaDistortion;    // é¢ç§¯å¤±çœŸ
        FaceData<double> stretchDistortion; // æ‹‰ä¼¸å¤±çœŸ

        // æ¯é¡¶ç‚¹å¤±çœŸï¼ˆæ’å€¼åï¼‰
        VertexData<double> vertexDistortion;
        VertexData<Vector3> perVertexColors;

        // ç»Ÿè®¡ä¿¡æ¯
        struct Statistics {
            double minDistortion;
            double maxDistortion;
            double avgDistortion;
            double stdDeviation;
            std::vector<double> histogram;
        } stats;
    };

    // æ ¸å¿ƒåˆ†æå‡½æ•°
    DistortionMetrics analyze(
        const HalfedgeMesh& mesh,
        const VertexPositionGeometry& geometry,
        const UVMapping& uvMapping);

    // å¤±çœŸåº¦é‡è®¡ç®—
    double computeAngleDistortion(Face f);
    double computeAreaDistortion(Face f);
    double computeStretchDistortion(Face f);

    // é¢œè‰²æ˜ å°„
    Vector3 distortionToColor(double distortion,
                             ColorMap colorMap = ColorMap::VIRIDIS);

private:
    // è¾…åŠ©å‡½æ•°
    double computeTriangleAngles(const std::array<Vector3, 3>& vertices);
    double computeTriangleArea(const std::array<Vector3, 3>& vertices);
    Matrix2x2 computeJacobian(Face f);
};
```

### 3.5 è¡¨é¢å¡«å……æ¨¡å— (SurfaceFiller)

**åŠŸèƒ½èŒè´£**ï¼š
- å¤šç§å›¾æ¡ˆç±»å‹ç”Ÿæˆ
- UVç©ºé—´å¸ƒå°”è¿ç®—
- è¾¹ç•Œè£å‰ª
- è·¯å¾„ä¼˜åŒ–

**å…³é”®æ¥å£**ï¼š
```cpp
class SurfaceFiller {
public:
    enum class PatternType {
        GRID,           // ç½‘æ ¼å›¾æ¡ˆ
        HEXAGONAL,      // å…­è¾¹å½¢å›¾æ¡ˆ
        SPIRAL,         // èºæ—‹å›¾æ¡ˆ
        HILBERT,        // å¸Œå°”ä¼¯ç‰¹æ›²çº¿
        CUSTOM          // è‡ªå®šä¹‰å›¾æ¡ˆ
    };

    struct FillingParameters {
        PatternType type = PatternType::GRID;
        double spacing = 0.02;
        double lineWidth = 0.001;
        bool adaptiveDensity = false;
        VertexData<double> densityField;
    };

    struct FillingResult {
        std::vector<std::vector<Vector2>> pathsUV;
        double totalLength;
        int pathCount;
    };

    FillingResult generateFilling(const FillingParameters& params);

    // å¯¼å‡ºåŠŸèƒ½
    void exportPathsToSVG(const std::vector<std::vector<Vector2>>& paths,
                         const std::string& filename);

private:
    // å›¾æ¡ˆç”Ÿæˆå™¨
    std::vector<std::vector<Vector2>> generateGridPattern(double spacing);
    std::vector<std::vector<Vector2>> generateHexagonalPattern(double spacing);
    std::vector<std::vector<Vector2>> generateSpiralPattern(double spacing);
    std::vector<std::vector<Vector2>> generateHilbertPattern(int order);

    // Clipper2é›†æˆ
    void clipPathsToUVBoundary(std::vector<std::vector<Vector2>>& paths);
    void performBooleanOperations(std::vector<std::vector<Vector2>>& paths);
};
```

### 3.6 é‡å¿ƒæ˜ å°„æ¨¡å— (BarycentricMapper) ğŸ†•

**åŠŸèƒ½èŒè´£**ï¼š
- UVç‚¹åˆ°3Dç‚¹çš„æ˜ å°„
- é‡å¿ƒåæ ‡è®¡ç®—
- ç©ºé—´ç´¢å¼•æ„å»º
- æ•°å€¼ç¨³å®šæ€§å¤„ç†

**å…³é”®æ¥å£**ï¼š
```cpp
class BarycentricMapper {
public:
    struct MappingConfig {
        double epsilon = 1e-8;          // æ•°å€¼å®¹å·®
        bool useAcceleration = true;    // ä½¿ç”¨ç©ºé—´åŠ é€Ÿç»“æ„
        int gridResolution = 100;       // ç©ºé—´ç½‘æ ¼åˆ†è¾¨ç‡
    };

    // åˆå§‹åŒ–
    void initialize(const HalfedgeMesh& mesh,
                   const VertexPositionGeometry& geometry,
                   const UVMapping& uvMapping,
                   const MappingConfig& config = {});

    // å•ç‚¹æ˜ å°„
    std::optional<Vector3> mapUVTo3D(const Vector2& uvPoint);

    // æ‰¹é‡ç‚¹æ˜ å°„
    std::vector<Vector3> mapUVPointsTo3D(
        const std::vector<Vector2>& uvPoints);

    // è·¯å¾„æ˜ å°„
    std::vector<Vector3> mapUVPathTo3D(
        const std::vector<Vector2>& uvPath,
        bool interpolate = true);

    // æŸ¥è¯¢å‡½æ•°
    std::optional<Face> findContainingTriangle(const Vector2& uvPoint);
    Vector3 computeBarycentricCoords(const Vector2& point,
                                     const Face& triangle);

private:
    // ç©ºé—´åŠ é€Ÿç»“æ„
    struct SpatialIndex {
        // ä½¿ç”¨CGALçš„AABBæ ‘
        typedef CGAL::AABB_tree</*..*/> AABBTree;
        std::unique_ptr<AABBTree> tree;

        // æˆ–ä½¿ç”¨ç½‘æ ¼ç´¢å¼•
        struct GridCell {
            std::vector<Face> faces;
        };
        std::vector<std::vector<GridCell>> grid;
    };

    SpatialIndex spatialIndex;

    // è¾…åŠ©å‡½æ•°
    bool pointInTriangle(const Vector2& p,
                        const Vector2& a,
                        const Vector2& b,
                        const Vector2& c);

    Vector3 interpolate3DPosition(const Vector3& baryCoords,
                                 const Face& face);
};
```

### 3.7 å›¾æ¡ˆå›æ˜ å°„æ¨¡å— (PatternBackMapper) ğŸ†•

**åŠŸèƒ½èŒè´£**ï¼š
- UVå›¾æ¡ˆåˆ°3Dæ›²é¢çš„å®Œæ•´æ˜ å°„
- è·¨ä¸‰è§’å½¢è·¯å¾„å¤„ç†
- æµ‹åœ°çº¿è®¡ç®—ï¼ˆå¯é€‰ï¼‰
- è·¯å¾„è¿ç»­æ€§ä¿è¯

**å…³é”®æ¥å£**ï¼š
```cpp
class PatternBackMapper {
public:
    struct BackMappingConfig {
        bool useGeodesic = false;       // æ˜¯å¦ä½¿ç”¨æµ‹åœ°çº¿
        bool splitAtEdges = true;       // æ˜¯å¦åœ¨è¾¹ç•Œåˆ†å‰²è·¯å¾„
        double samplingDensity = 0.001; // è·¯å¾„é‡‡æ ·å¯†åº¦
        bool preserveTopology = true;   // ä¿æŒæ‹“æ‰‘ç»“æ„
    };

    struct MappedPattern {
        std::vector<std::vector<Vector3>> paths3D;
        std::vector<double> pathLengths;
        double totalLength;

        // æ˜ å°„è´¨é‡æŒ‡æ ‡
        struct QualityMetrics {
            double maxDeviation;        // æœ€å¤§åå·®
            double avgDeviation;         // å¹³å‡åå·®
            int discontinuities;        // ä¸è¿ç»­ç‚¹æ•°é‡
        } quality;
    };

    // ä¸»æ˜ å°„å‡½æ•°
    MappedPattern mapPatternTo3D(
        const FillingResult& uvPattern,
        const UVMapping& uvMapping,
        const HalfedgeMesh& mesh,
        const VertexPositionGeometry& geometry,
        const BackMappingConfig& config = {});

    // å¯¼å‡ºåŠŸèƒ½
    void exportPaths3D(const MappedPattern& pattern,
                      const std::string& filename);

    void exportAsPolylines(const MappedPattern& pattern,
                          const std::string& filename);

private:
    // è·¯å¾„æ˜ å°„æ ¸å¿ƒ
    std::vector<Vector3> mapSinglePath(
        const std::vector<Vector2>& uvPath);

    // è·¨ä¸‰è§’å½¢å¤„ç†
    struct PathSegment {
        Face face;
        Vector2 entryPoint;
        Vector2 exitPoint;
        Edge crossedEdge;
    };

    std::vector<PathSegment> computePathSegments(
        const Vector2& start,
        const Vector2& end);

    // è¾¹ç•Œå¤„ç†
    Vector3 computeEdgeCrossing(
        const Edge& edge,
        const Vector2& uvPoint,
        const Vector3& baryCoords);

    // æµ‹åœ°çº¿è®¡ç®—ï¼ˆä½¿ç”¨CGALï¼‰
    std::vector<Vector3> computeGeodesicPath(
        const Vector3& start,
        const Vector3& end,
        const HalfedgeMesh& mesh);

    // è¿ç»­æ€§ä¿®å¤
    void ensurePathContinuity(
        std::vector<Vector3>& path,
        double tolerance = 1e-6);
};
```

### 3.8 å¯è§†åŒ–æ¨¡å— (UVVisualization) ğŸ†•

**åŠŸèƒ½èŒè´£**ï¼š
- å¤±çœŸåº¦å¯è§†åŒ–æ¸²æŸ“
- çº¹ç†å›¾ç”Ÿæˆ
- UVå¸ƒå±€æ˜¾ç¤º
- 3D/UVå¯¹æ¯”è§†å›¾

**å…³é”®æ¥å£**ï¼š
```cpp
class UVVisualization {
public:
    struct VisualizationConfig {
        enum ViewMode {
            VIEW_3D,           // 3Dè§†å›¾
            VIEW_UV,           // UVå¹³é¢è§†å›¾
            VIEW_SPLIT,        // åˆ†å±å¯¹æ¯”
            VIEW_OVERLAY       // å åŠ æ˜¾ç¤º
        };

        ViewMode mode = VIEW_SPLIT;
        bool showWireframe = true;
        bool showDistortion = true;
        bool showCuts = true;
        float wireframeWidth = 1.0f;
    };

    // æ¸²æŸ“å‡½æ•°
    void render(const VisualizationConfig& config);

    // å¤±çœŸçº¹ç†ç”Ÿæˆ
    void generateDistortionTexture(
        const UVMapping& mapping,
        const DistortionMetrics& distortion,
        const std::string& filename,
        int resolution = 1024);

    // é¢œè‰²æ˜ å°„
    void applyDistortionColors(
        const HalfedgeMesh& mesh,
        const VertexData<Vector3>& colors);

    // UVå¸ƒå±€æ¸²æŸ“
    void renderUVLayout(
        const UVMapping& mapping,
        const ImVec2& canvasSize);

    // äº¤äº’å¼å¤±çœŸå›¾
    void renderInteractiveHeatmap(
        const DistortionMetrics& distortion,
        ImGuiIO& io);

private:
    // OpenGLèµ„æº
    struct GLResources {
        GLuint meshVAO, meshVBO, meshEBO;
        GLuint uvVAO, uvVBO, uvEBO;
        GLuint distortionTexture;
        GLuint shaderProgram;
    } glResources;

    // ç€è‰²å™¨ç®¡ç†
    void compileShaders();
    void updateBuffers();
};
```

---

## 4. ç®—æ³•åŸç†å’Œå®ç°ç»†èŠ‚

### 4.1 å˜åˆ†åˆ‡å‰²ç®—æ³•åŸç†

#### 4.1.1 Yamabeèƒ½é‡å‡½æ•°

å˜åˆ†åˆ‡å‰²åŸºäºYamabeæµï¼Œé€šè¿‡æœ€å°åŒ–ä»¥ä¸‹èƒ½é‡å‡½æ•°å¯»æ‰¾æœ€ä¼˜åˆ‡ç¼ï¼š

$$E_{total} = \alpha E_{length} + \beta E_{distortion} + \gamma E_{visibility}$$

å…¶ä¸­ï¼š
- $E_{length}$ï¼šåˆ‡ç¼é•¿åº¦æ­£åˆ™åŒ–é¡¹
- $E_{distortion}$ï¼šHenckyå¤±çœŸåº¦é‡
- $E_{visibility}$ï¼šå¯è§æ€§çº¦æŸé¡¹

#### 4.1.2 æ°´å¹³é›†æ¼”åŒ–

ä½¿ç”¨æ°´å¹³é›†æ–¹æ³•éšå¼è¡¨ç¤ºåˆ‡ç¼è¾¹ç•Œï¼š

$$\frac{\partial \phi}{\partial t} + F|\nabla \phi| = 0$$

å…¶ä¸­$\phi$æ˜¯æ°´å¹³é›†å‡½æ•°ï¼Œ$F$æ˜¯é€Ÿåº¦åœºï¼Œç”±å½¢çŠ¶å¯¼æ•°å†³å®šã€‚

#### 4.1.3 å½¢çŠ¶å¯¼æ•°è®¡ç®—

```cpp
Vector<double> VariationalCutter::computeShapeDerivative() {
    Vector<double> derivative(mesh->nVertices());

    for (Vertex v : mesh->vertices()) {
        double lengthGrad = computeLengthGradient(v);
        double distortionGrad = computeDistortionGradient(v);
        double visibilityGrad = computeVisibilityGradient(v);

        derivative[v.getIndex()] =
            params.lengthWeight * lengthGrad +
            params.distortionWeight * distortionGrad +
            params.visibilityWeight * visibilityGrad;
    }

    return derivative;
}
```

### 4.2 BFFç®—æ³•åŸç†

#### 4.2.1 å…±å½¢æ˜ å°„

BFFé€šè¿‡æ±‚è§£ä»¥ä¸‹çº¿æ€§ç³»ç»Ÿå®ç°å…±å½¢æ˜ å°„ï¼š

$$\Delta u = K - \tilde{K}$$

å…¶ä¸­ï¼š
- $\Delta$ï¼šç¦»æ•£æ‹‰æ™®æ‹‰æ–¯ç®—å­
- $K$ï¼šåŸå§‹é«˜æ–¯æ›²ç‡
- $\tilde{K}$ï¼šç›®æ ‡é«˜æ–¯æ›²ç‡
- $u$ï¼šå¯¹æ•°å…±å½¢å› å­

#### 4.2.2 é”¥ç‚¹ä¼˜åŒ–

é”¥ç‚¹é…ç½®é€šè¿‡è´ªå¿ƒç®—æ³•é€‰æ‹©ï¼š

```cpp
void TextureMapper::optimizeConeConfiguration() {
    std::priority_queue<ConeCandidate> candidates;

    // è¯„ä¼°æ‰€æœ‰é¡¶ç‚¹ä½œä¸ºé”¥ç‚¹çš„æ”¶ç›Š
    for (Vertex v : mesh->vertices()) {
        if (!v.isBoundary()) {
            double benefit = evaluateConeVertex(v);
            candidates.push({v, benefit});
        }
    }

    // è´ªå¿ƒé€‰æ‹©é”¥ç‚¹
    std::set<Vertex> cones;
    while (!candidates.empty() && cones.size() < maxCones) {
        ConeCandidate best = candidates.top();
        candidates.pop();

        if (best.benefit > threshold) {
            cones.insert(best.vertex);
            updateNeighborBenefits(best.vertex);
        }
    }
}
```

### 4.3 å¤±çœŸåº¦é‡è®¡ç®—

#### 4.3.1 è§’åº¦å¤±çœŸ

è¡¡é‡UVæ˜ å°„å‰åä¸‰è§’å½¢å†…è§’çš„å˜åŒ–ï¼š

```cpp
double UVDistortionAnalyzer::computeAngleDistortion(Face f) {
    // è·å–3Då’ŒUVç©ºé—´çš„ä¸‰ä¸ªé¡¶ç‚¹
    std::array<Vector3, 3> pos3D = getFaceVertices3D(f);
    std::array<Vector2, 3> posUV = getFaceVerticesUV(f);

    // è®¡ç®—3Dç©ºé—´çš„ä¸‰ä¸ªå†…è§’
    std::array<double, 3> angles3D;
    for (int i = 0; i < 3; i++) {
        Vector3 v1 = pos3D[(i+1)%3] - pos3D[i];
        Vector3 v2 = pos3D[(i+2)%3] - pos3D[i];
        angles3D[i] = acos(dot(v1, v2) / (norm(v1) * norm(v2)));
    }

    // è®¡ç®—UVç©ºé—´çš„ä¸‰ä¸ªå†…è§’
    std::array<double, 3> anglesUV;
    for (int i = 0; i < 3; i++) {
        Vector2 v1 = posUV[(i+1)%3] - posUV[i];
        Vector2 v2 = posUV[(i+2)%3] - posUV[i];
        anglesUV[i] = acos(dot(v1, v2) / (norm(v1) * norm(v2)));
    }

    // è®¡ç®—æœ€å¤§è§’åº¦åå·®
    double maxDeviation = 0;
    for (int i = 0; i < 3; i++) {
        maxDeviation = std::max(maxDeviation,
                               std::abs(angles3D[i] - anglesUV[i]));
    }

    return maxDeviation / M_PI;  // å½’ä¸€åŒ–åˆ°[0,1]
}
```

#### 4.3.2 é¢ç§¯å¤±çœŸ

æ¯”è¾ƒUVæ˜ å°„å‰åä¸‰è§’å½¢é¢ç§¯çš„æ¯”ç‡ï¼š

```cpp
double UVDistortionAnalyzer::computeAreaDistortion(Face f) {
    double area3D = geometry->faceArea(f);
    double areaUV = computeUVFaceArea(f);

    // è®¡ç®—é¢ç§¯æ¯”ç‡ï¼ˆå¯¹æ•°ç©ºé—´ï¼‰
    double ratio = areaUV / area3D;
    return std::abs(std::log(ratio));
}
```

#### 4.3.3 æ‹‰ä¼¸å¤±çœŸ

åŸºäºé›…å¯æ¯”çŸ©é˜µçš„å¥‡å¼‚å€¼åˆ†è§£ï¼š

```cpp
double UVDistortionAnalyzer::computeStretchDistortion(Face f) {
    // è®¡ç®—æ˜ å°„çš„é›…å¯æ¯”çŸ©é˜µ
    Matrix2x2 J = computeJacobian(f);

    // SVDåˆ†è§£è·å–å¥‡å¼‚å€¼
    Eigen::JacobiSVD<Eigen::Matrix2d> svd(J);
    double s1 = svd.singularValues()(0);
    double s2 = svd.singularValues()(1);

    // L2æ‹‰ä¼¸åº¦é‡
    double L2_stretch = sqrt((s1*s1 + s2*s2) / 2.0);

    // Lâˆæ‹‰ä¼¸åº¦é‡
    double Linf_stretch = std::max(s1, s2);

    // ç»¼åˆæ‹‰ä¼¸å¤±çœŸ
    return 0.5 * (L2_stretch + Linf_stretch);
}
```

### 4.4 é‡å¿ƒåæ ‡æ˜ å°„ç®—æ³•

#### 4.4.1 ç‚¹å®šä½ç®—æ³•

ä½¿ç”¨AABBæ ‘åŠ é€ŸUVç‚¹å®šä½ï¼š

```cpp
std::optional<Face> BarycentricMapper::findContainingTriangle(
    const Vector2& uvPoint) {

    if (config.useAcceleration) {
        // ä½¿ç”¨AABBæ ‘æŸ¥è¯¢
        auto query = spatialIndex.tree->query(uvPoint);
        if (query.has_value()) {
            return query.value();
        }
    } else {
        // æš´åŠ›æœç´¢
        for (Face f : mesh->faces()) {
            if (pointInTriangle(uvPoint, f)) {
                return f;
            }
        }
    }

    return std::nullopt;
}
```

#### 4.4.2 é‡å¿ƒåæ ‡è®¡ç®—

```cpp
Vector3 BarycentricMapper::computeBarycentricCoords(
    const Vector2& p, const Face& triangle) {

    // è·å–ä¸‰è§’å½¢çš„UVåæ ‡
    auto vertices = triangle.adjacentVertices();
    Vector2 a = uvCoords[vertices[0]];
    Vector2 b = uvCoords[vertices[1]];
    Vector2 c = uvCoords[vertices[2]];

    // è®¡ç®—é‡å¿ƒåæ ‡
    Vector2 v0 = c - a;
    Vector2 v1 = b - a;
    Vector2 v2 = p - a;

    double d00 = dot(v0, v0);
    double d01 = dot(v0, v1);
    double d11 = dot(v1, v1);
    double d20 = dot(v2, v0);
    double d21 = dot(v2, v1);

    double denom = d00 * d11 - d01 * d01;

    // æ•°å€¼ç¨³å®šæ€§æ£€æŸ¥
    if (std::abs(denom) < config.epsilon) {
        // é€€åŒ–ä¸‰è§’å½¢å¤„ç†
        return handleDegenerateCase(p, triangle);
    }

    double v = (d11 * d20 - d01 * d21) / denom;
    double w = (d00 * d21 - d01 * d20) / denom;
    double u = 1.0 - v - w;

    return Vector3(u, v, w);
}
```

### 4.5 è·¨ä¸‰è§’å½¢è·¯å¾„æ˜ å°„

#### 4.5.1 è·¯å¾„åˆ†æ®µç®—æ³•

```cpp
std::vector<PathSegment> PatternBackMapper::computePathSegments(
    const Vector2& start, const Vector2& end) {

    std::vector<PathSegment> segments;

    // æ‰¾åˆ°èµ·å§‹ä¸‰è§’å½¢
    auto startFace = mapper.findContainingTriangle(start);
    if (!startFace) return segments;

    Vector2 current = start;
    Face currentFace = *startFace;

    while (norm(current - end) > epsilon) {
        PathSegment segment;
        segment.face = currentFace;
        segment.entryPoint = current;

        // è®¡ç®—å°„çº¿ä¸ä¸‰è§’å½¢è¾¹çš„äº¤ç‚¹
        auto intersection = computeRayTriangleExit(
            current, end - current, currentFace);

        if (intersection.has_value()) {
            segment.exitPoint = intersection->point;
            segment.crossedEdge = intersection->edge;

            // ç§»åŠ¨åˆ°ç›¸é‚»ä¸‰è§’å½¢
            currentFace = intersection->edge.twin().face();
            current = segment.exitPoint;

            // æ·»åŠ å°åç§»é¿å…æ•°å€¼é—®é¢˜
            Vector2 direction = normalize(end - current);
            current = current + epsilon * direction;
        } else {
            // è·¯å¾„ç»ˆç‚¹åœ¨å½“å‰ä¸‰è§’å½¢å†…
            segment.exitPoint = end;
            segments.push_back(segment);
            break;
        }

        segments.push_back(segment);
    }

    return segments;
}
```

#### 4.5.2 æµ‹åœ°çº¿è®¡ç®—ï¼ˆå¯é€‰ï¼‰

ä½¿ç”¨CGALçš„Surface_mesh_shortest_pathï¼š

```cpp
std::vector<Vector3> PatternBackMapper::computeGeodesicPath(
    const Vector3& start, const Vector3& end,
    const HalfedgeMesh& mesh) {

    // è½¬æ¢ä¸ºCGALæ ¼å¼
    CGAL::Surface_mesh<Point_3> cgalMesh = convertToCGAL(mesh);

    // æ„å»ºæœ€çŸ­è·¯å¾„æŸ¥è¯¢å¯¹è±¡
    typedef CGAL::Surface_mesh_shortest_path<
        CGAL::Surface_mesh<Point_3>,
        CGAL::Surface_mesh_shortest_path_traits<Point_3>
    > Shortest_path;

    Shortest_path shortestPath(cgalMesh);

    // è®¾ç½®æºç‚¹
    shortestPath.add_source_point(toCGALPoint(start));

    // è®¡ç®—åˆ°ç›®æ ‡ç‚¹çš„æœ€çŸ­è·¯å¾„
    auto pathPoints = shortestPath.shortest_path_points_to_source_points(
        toCGALPoint(end));

    // è½¬æ¢å›å†…éƒ¨æ ¼å¼
    std::vector<Vector3> geodesicPath;
    for (const auto& p : pathPoints) {
        geodesicPath.push_back(fromCGALPoint(p));
    }

    return geodesicPath;
}
```

---

## 5. å®æ–½è®¡åˆ’å’Œé‡Œç¨‹ç¢‘

### 5.1 é¡¹ç›®æ—¶é—´çº¿

```mermaid
gantt
    title Mini-Unfold3D å®æ–½è®¡åˆ’
    dateFormat  YYYY-MM-DD
    section ç¬¬ä¸€é˜¶æ®µ
    UVå¤±çœŸå¯è§†åŒ–           :a1, 2025-02-01, 2d
    å¤±çœŸåº¦é‡è®¡ç®—            :a2, after a1, 1d
    é¢œè‰²ç¼–ç æ¸²æŸ“            :a3, after a2, 1d

    section ç¬¬äºŒé˜¶æ®µ
    é‡å¿ƒåæ ‡æ˜ å°„            :b1, after a3, 3d
    ç©ºé—´ç´¢å¼•æ„å»º            :b2, after b1, 1d
    æ‰¹é‡ç‚¹æ˜ å°„ä¼˜åŒ–          :b3, after b2, 1d

    section ç¬¬ä¸‰é˜¶æ®µ
    è·¨ä¸‰è§’å½¢è·¯å¾„å¤„ç†        :c1, after b3, 4d
    è¾¹ç•Œäº¤å‰æ£€æµ‹            :c2, after c1, 2d
    æµ‹åœ°çº¿é›†æˆ(å¯é€‰)        :c3, after c2, 2d

    section ç¬¬å››é˜¶æ®µ
    ç³»ç»Ÿé›†æˆ                :d1, after c3, 2d
    ç«¯åˆ°ç«¯æµ‹è¯•              :d2, after d1, 2d
    æ€§èƒ½ä¼˜åŒ–                :d3, after d2, 1d

    section ç¬¬äº”é˜¶æ®µ
    æ–‡æ¡£ç¼–å†™                :e1, after d3, 1d
    ç¤ºä¾‹åˆ¶ä½œ                :e2, after e1, 1d
    å‘å¸ƒå‡†å¤‡                :e3, after e2, 1d
```

### 5.2 é‡Œç¨‹ç¢‘å®šä¹‰

#### M1: åŸºç¡€å¯è§†åŒ–å®Œæˆï¼ˆç¬¬3å¤©ï¼‰
- âœ… UVå¤±çœŸåº¦é‡è®¡ç®—å®ç°
- âœ… å¤±çœŸçƒ­åŠ›å›¾æ¸²æŸ“
- âœ… ImGuié›†æˆæ˜¾ç¤º
- **äº¤ä»˜ç‰©**: å¯è§†åŒ–å¤±çœŸçš„UVå±•å¼€ç»“æœ

#### M2: æ˜ å°„æ ¸å¿ƒå®Œæˆï¼ˆç¬¬8å¤©ï¼‰
- âœ… é‡å¿ƒåæ ‡æ˜ å°„å®ç°
- âœ… ç©ºé—´åŠ é€Ÿç»“æ„æ„å»º
- âœ… æ‰¹é‡æ˜ å°„ä¼˜åŒ–
- **äº¤ä»˜ç‰©**: UVåˆ°3Dçš„ç‚¹æ˜ å°„åŠŸèƒ½

#### M3: è·¯å¾„æ˜ å°„å®Œæˆï¼ˆç¬¬15å¤©ï¼‰
- âœ… è·¨ä¸‰è§’å½¢è·¯å¾„å¤„ç†
- âœ… è¾¹ç•Œå¤„ç†ç®—æ³•
- âœ… è¿ç»­æ€§ä¿è¯
- **äº¤ä»˜ç‰©**: å®Œæ•´çš„å›¾æ¡ˆå›æ˜ å°„åŠŸèƒ½

#### M4: ç³»ç»Ÿé›†æˆå®Œæˆï¼ˆç¬¬20å¤©ï¼‰
- âœ… å…¨æµç¨‹é›†æˆæµ‹è¯•
- âœ… æ€§èƒ½è¾¾æ ‡ï¼ˆ<5ç§’å¤„ç†10ké¢ç‰‡ï¼‰
- âœ… Bugä¿®å¤å®Œæˆ
- **äº¤ä»˜ç‰©**: å¯å‘å¸ƒçš„Demoç³»ç»Ÿ

#### M5: é¡¹ç›®äº¤ä»˜ï¼ˆç¬¬23å¤©ï¼‰
- âœ… å®Œæ•´æ–‡æ¡£
- âœ… ç¤ºä¾‹å’Œæ•™ç¨‹
- âœ… å‘å¸ƒåŒ…å‡†å¤‡
- **äº¤ä»˜ç‰©**: å®Œæ•´çš„Mini-Unfold3Dç³»ç»Ÿ

### 5.3 èµ„æºåˆ†é…

| é˜¶æ®µ | äººåŠ›éœ€æ±‚ | ä¸»è¦æŠ€èƒ½è¦æ±‚ | å·¥ä½œé‡(äººå¤©) |
|------|----------|--------------|--------------|
| å¤±çœŸå¯è§†åŒ– | 1äºº | OpenGL, å›¾å½¢å­¦ | 2 |
| é‡å¿ƒæ˜ å°„ | 1äºº | è®¡ç®—å‡ ä½•, æ•°å€¼è®¡ç®— | 3 |
| è·¯å¾„æ˜ å°„ | 2äºº | ç®—æ³•, CGAL | 5 |
| ç³»ç»Ÿé›†æˆ | 1äºº | C++, è½¯ä»¶å·¥ç¨‹ | 3 |
| æµ‹è¯•ä¼˜åŒ– | 1äºº | æµ‹è¯•, æ€§èƒ½åˆ†æ | 2 |
| æ–‡æ¡£ | 1äºº | æŠ€æœ¯å†™ä½œ | 2 |

**æ€»è®¡**: çº¦17äººå¤©

### 5.4 æµ‹è¯•è®¡åˆ’

#### å•å…ƒæµ‹è¯•
```cpp
// å¤±çœŸè®¡ç®—æµ‹è¯•
TEST(DistortionTest, AngleDistortion) {
    // åˆ›å»ºä¸€ä¸ªç­‰è¾¹ä¸‰è§’å½¢
    auto triangle = createEquilateralTriangle();

    // UVæ˜ å°„ä¸ºç›´è§’ä¸‰è§’å½¢
    auto uvMapping = mapToRightTriangle();

    // è®¡ç®—å¤±çœŸ
    UVDistortionAnalyzer analyzer;
    auto distortion = analyzer.computeAngleDistortion(triangle);

    // éªŒè¯å¤±çœŸå€¼
    EXPECT_NEAR(distortion, expectedValue, 1e-6);
}

// é‡å¿ƒåæ ‡æµ‹è¯•
TEST(BarycentricTest, PointMapping) {
    // æµ‹è¯•ä¸‰è§’å½¢å†…éƒ¨ç‚¹
    Vector2 uvPoint(0.3, 0.4);
    auto mapped3D = mapper.mapUVTo3D(uvPoint);
    ASSERT_TRUE(mapped3D.has_value());

    // éªŒè¯æ˜ å°„æ­£ç¡®æ€§
    auto remapped = projectTo2D(mapped3D.value());
    EXPECT_NEAR(distance(remapped, uvPoint), 0, 1e-6);
}
```

#### é›†æˆæµ‹è¯•
- data/spot.objæ¨¡å‹å®Œæ•´æµç¨‹æµ‹è¯•
- data/bunny.objæ¨¡å‹æ€§èƒ½æµ‹è¯•
- å¤æ‚æ‹“æ‰‘æ¨¡å‹é²æ£’æ€§æµ‹è¯•

#### æ€§èƒ½åŸºå‡†
| æ¨¡å‹è§„æ¨¡ | é¢„å¤„ç† | åˆ‡å‰² | UVå±•å¼€ | å¤±çœŸåˆ†æ | å›¾æ¡ˆæ˜ å°„ | æ€»æ—¶é—´ |
|---------|--------|------|---------|----------|----------|--------|
| 1ké¢ç‰‡ | <0.1s | <0.5s | <0.2s | <0.1s | <0.3s | <1.5s |
| 10ké¢ç‰‡ | <0.5s | <2s | <1s | <0.5s | <1s | <5s |
| 100ké¢ç‰‡ | <5s | <20s | <10s | <5s | <10s | <50s |

---

## 6. é£é™©è¯„ä¼°å’Œåº”å¯¹ç­–ç•¥

### 6.1 æŠ€æœ¯é£é™©

#### é£é™©1: æ•°å€¼ç¨³å®šæ€§é—®é¢˜ ğŸ”´ é«˜
**æè¿°**: é‡å¿ƒåæ ‡è®¡ç®—åœ¨é€€åŒ–ä¸‰è§’å½¢æˆ–è¾¹ç•Œç‚¹å¯èƒ½å¤±è´¥

**å½±å“**:
- æ˜ å°„ç»“æœä¸æ­£ç¡®
- ç¨‹åºå´©æºƒ
- è§†è§‰ç‘•ç–µ

**ç¼“è§£æªæ–½**:
1. å®ç°robustå‡ ä½•è°“è¯
2. ä½¿ç”¨ç²¾ç¡®ç®—æœ¯åº“ï¼ˆCGAL Exact_predicatesï¼‰
3. æ·»åŠ epsilonå®¹å·®å¤„ç†
4. é€€åŒ–æƒ…å†µç‰¹æ®Šå¤„ç†

```cpp
// é²æ£’æ€§å¤„ç†ç¤ºä¾‹
Vector3 computeRobustBarycentricCoords(const Vector2& p,
                                       const Face& triangle) {
    // ä½¿ç”¨CGALç²¾ç¡®è°“è¯
    typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
    K::Point_2 query(p.x, p.y);

    // è½¬æ¢ä¸ºCGALä¸‰è§’å½¢
    K::Triangle_2 cgalTriangle = convertToCGAL(triangle);

    // ç²¾ç¡®çš„åŒ…å«æµ‹è¯•
    if (!cgalTriangle.has_on(query)) {
        // å¯»æ‰¾æœ€è¿‘çš„ä¸‰è§’å½¢
        return findNearestTriangle(p);
    }

    // è®¡ç®—é‡å¿ƒåæ ‡
    auto coords = CGAL::barycentric_coordinates(query, cgalTriangle);
    return Vector3(coords[0], coords[1], coords[2]);
}
```

#### é£é™©2: æ€§èƒ½ç“¶é¢ˆ ğŸŸ¡ ä¸­
**æè¿°**: å¤§è§„æ¨¡ç½‘æ ¼å¤„ç†å¯èƒ½è¶…æ—¶

**å½±å“**:
- ç”¨æˆ·ä½“éªŒå·®
- å†…å­˜æº¢å‡º
- å“åº”è¿Ÿç¼“

**ç¼“è§£æªæ–½**:
1. å®ç°LOD (Level of Detail) ç­–ç•¥
2. å¹¶è¡ŒåŒ–è®¡ç®—å¯†é›†å‹æ“ä½œ
3. ä½¿ç”¨ç©ºé—´æ•°æ®ç»“æ„åŠ é€Ÿ
4. å¢é‡å¼å¤„ç†

```cpp
// å¹¶è¡ŒåŒ–ç¤ºä¾‹
void processLargeMesh(const HalfedgeMesh& mesh) {
    #pragma omp parallel for
    for (int i = 0; i < mesh.nFaces(); i++) {
        Face f = mesh.face(i);
        processTriangle(f);
    }
}
```

#### é£é™©3: è·¨å¹³å°å…¼å®¹æ€§ ğŸŸ¡ ä¸­
**æè¿°**: Windows/Linux/Macè¡¨ç°ä¸ä¸€è‡´

**å½±å“**:
- æ„å»ºå¤±è´¥
- åŠŸèƒ½å·®å¼‚
- æ€§èƒ½å·®å¼‚

**ç¼“è§£æªæ–½**:
1. ä½¿ç”¨CMakeç®¡ç†æ„å»º
2. é¿å…å¹³å°ç‰¹å®šAPI
3. CI/CDå¤šå¹³å°æµ‹è¯•
4. æ¡ä»¶ç¼–è¯‘å¤„ç†å·®å¼‚

### 6.2 é¡¹ç›®é£é™©

#### é£é™©4: ä¾èµ–åº“ç‰ˆæœ¬å†²çª ğŸŸ¡ ä¸­
**æè¿°**: CGALã€Eigenã€geometry-centralç‰ˆæœ¬ä¸å…¼å®¹

**å½±å“**:
- ç¼–è¯‘é”™è¯¯
- è¿è¡Œæ—¶é”™è¯¯
- åŠŸèƒ½ç¼ºå¤±

**ç¼“è§£æªæ–½**:
1. ä½¿ç”¨vcpkgå›ºå®šç‰ˆæœ¬
2. åˆ›å»ºDockerå®¹å™¨
3. è¯¦ç»†è®°å½•ä¾èµ–ç‰ˆæœ¬
4. æä¾›é¢„ç¼–è¯‘åŒ…

#### é£é™©5: éœ€æ±‚å˜æ›´ ğŸŸ¢ ä½
**æè¿°**: åŠŸèƒ½éœ€æ±‚åœ¨å¼€å‘ä¸­å˜åŒ–

**å½±å“**:
- å»¶æœŸäº¤ä»˜
- é‡å¤å·¥ä½œ
- æ¶æ„è°ƒæ•´

**ç¼“è§£æªæ–½**:
1. æ¨¡å—åŒ–è®¾è®¡
2. è¿­ä»£å¼€å‘
3. æ—©æœŸåŸå‹éªŒè¯
4. åŠæ—¶æ²Ÿé€šç¡®è®¤

### 6.3 é£é™©çŸ©é˜µ

```
å½±å“ç¨‹åº¦
    â†‘
é«˜  â”‚ R1:æ•°å€¼ç¨³å®šæ€§ â”‚              â”‚              â”‚
    â”‚              â”‚              â”‚              â”‚
ä¸­  â”‚              â”‚ R2:æ€§èƒ½ç“¶é¢ˆ  â”‚              â”‚
    â”‚              â”‚ R3:è·¨å¹³å°    â”‚              â”‚
    â”‚              â”‚ R4:ä¾èµ–å†²çª  â”‚              â”‚
ä½  â”‚              â”‚              â”‚ R5:éœ€æ±‚å˜æ›´  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      ä½            ä¸­             é«˜
                   å‘ç”Ÿæ¦‚ç‡ â†’

å›¾ä¾‹: R1-R5 ä¸ºå·²è¯†åˆ«é£é™©
```

### 6.4 åº”æ€¥è®¡åˆ’

**Plan A (ä¸»è®¡åˆ’)**: å®Œæ•´å®ç°æ‰€æœ‰åŠŸèƒ½
- æ—¶é—´: 23å¤©
- èµ„æº: 2-3äºº
- æˆåŠŸç‡: 70%

**Plan B (é™çº§è®¡åˆ’)**: æ ¸å¿ƒåŠŸèƒ½+ç®€åŒ–ç‰ˆæœ¬
- ç§»é™¤æµ‹åœ°çº¿è®¡ç®—
- ç®€åŒ–å¤±çœŸå¯è§†åŒ–
- æ—¶é—´: 18å¤©
- æˆåŠŸç‡: 90%

**Plan C (æœ€å°å¯è¡Œç‰ˆæœ¬)**: ä»…å®ç°åŸºç¡€æ˜ å°„
- ä»…æ”¯æŒå•ä¸€UVå›¾è¡¨
- åŸºç¡€é‡å¿ƒæ˜ å°„
- æ—¶é—´: 12å¤©
- æˆåŠŸç‡: 95%

---

## 7. æŠ€æœ¯æ ˆå’Œä¾èµ–

### 7.1 æ ¸å¿ƒä¾èµ–

| åº“å | ç‰ˆæœ¬ | ç”¨é€” | è®¸å¯è¯ |
|------|------|------|--------|
| CGAL | 5.5+ | è®¡ç®—å‡ ä½•ç®—æ³• | GPL/LGPL |
| geometry-central | latest | ç¦»æ•£å¾®åˆ†å‡ ä½• | MIT |
| Eigen3 | 3.4+ | çº¿æ€§ä»£æ•° | MPL2 |
| Clipper2 | 1.2+ | å¸ƒå°”è¿ç®— | Boost |
| ImGui | 1.89+ | ç”¨æˆ·ç•Œé¢ | MIT |
| OpenGL | 3.3+ | 3Dæ¸²æŸ“ | - |
| GLM | 0.9.9+ | æ•°å­¦åº“ | MIT |
| spdlog | 1.11+ | æ—¥å¿—ç³»ç»Ÿ | MIT |

### 7.2 æ„å»ºå·¥å…·

```cmake
# CMakePresets.json
{
  "version": 3,
  "configurePresets": [
    {
      "name": "unfold3d-debug",
      "displayName": "Unfold3D Debug",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/${presetName}",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_CXX_STANDARD": "17",
        "ENABLE_TESTING": "ON",
        "BUILD_EXAMPLES": "ON"
      }
    }
  ]
}
```

### 7.3 å¼€å‘ç¯å¢ƒ

**æ¨èé…ç½®**:
- æ“ä½œç³»ç»Ÿ: Windows 10/11, Ubuntu 20.04+, macOS 11+
- ç¼–è¯‘å™¨: MSVC 2019+, GCC 9+, Clang 12+
- CMake: 3.20+
- vcpkg: latest
- GPU: æ”¯æŒOpenGL 3.3+

**IDEæ”¯æŒ**:
- Visual Studio 2022 (æ¨è)
- Visual Studio Code + CMake Tools
- CLion
- Qt Creator

---

## 8. å‚è€ƒæ–‡çŒ®

### å­¦æœ¯è®ºæ–‡

1. **Variational Surface Cutting**
   - Sharp, N., & Crane, K. (2018)
   - ACM Transactions on Graphics (TOG)
   - æä¾›äº†å˜åˆ†åˆ‡å‰²çš„ç†è®ºåŸºç¡€

2. **Boundary First Flattening**
   - Sawhney, R., & Crane, K. (2017)
   - ACM Transactions on Graphics (TOG)
   - BFFç®—æ³•çš„åŸå§‹è®ºæ–‡

3. **Least Squares Conformal Maps**
   - LÃ©vy, B., et al. (2002)
   - ACM SIGGRAPH
   - å…±å½¢æ˜ å°„çš„ç»å…¸æ–¹æ³•

4. **ABF++: Fast and Robust Angle Based Flattening**
   - Sheffer, A., et al. (2005)
   - ACM Transactions on Graphics
   - è§’åº¦ä¿æŒçš„å‚æ•°åŒ–æ–¹æ³•

5. **Geodesics in Heat**
   - Crane, K., et al. (2013)
   - ACM Transactions on Graphics
   - å¿«é€Ÿæµ‹åœ°çº¿è®¡ç®—

### æŠ€æœ¯æ–‡æ¡£

6. **CGALç”¨æˆ·æ‰‹å†Œ**
   - https://doc.cgal.org/latest/Manual/index.html
   - ç‰¹åˆ«æ˜¯Surface_meshå’ŒBGLç« èŠ‚

7. **geometry-centralæ–‡æ¡£**
   - https://geometry-central.net/
   - ç¦»æ•£å¾®åˆ†å‡ ä½•æ“ä½œæŒ‡å—

8. **OpenGLç¼–ç¨‹æŒ‡å—**
   - https://www.opengl.org/documentation/
   - æ¸²æŸ“ç®¡çº¿å’Œç€è‰²å™¨ç¼–ç¨‹

### å¼€æºé¡¹ç›®

9. **libigl**
   - https://libigl.github.io/
   - æä¾›äº†è®¸å¤šå‡ ä½•å¤„ç†ç®—æ³•å‚è€ƒ

10. **Blender UVå·¥å…·æºç **
    - https://github.com/blender/blender
    - å·¥ä¸šçº§UVå±•å¼€å®ç°å‚è€ƒ

### ä¹¦ç±

11. **Polygon Mesh Processing**
    - Botsch, M., et al. (2010)
    - A K Peters/CRC Press
    - ç½‘æ ¼å¤„ç†çš„å…¨é¢ä»‹ç»

12. **Discrete Differential Geometry**
    - Crane, K. (2020)
    - ç¦»æ•£å¾®åˆ†å‡ ä½•çš„ç°ä»£æ–¹æ³•

---

## é™„å½•A: ä»£ç ç»„ç»‡ç»“æ„

```
mini-unfold3d/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ CMakePresets.json
â”œâ”€â”€ vcpkg.json
â”œâ”€â”€ README.md
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ API_REFERENCE.md
â”‚   â”œâ”€â”€ USER_MANUAL.md
â”‚   â””â”€â”€ TECHNICAL_ROADMAP.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ MeshProcessor.h/cpp
â”‚   â”‚   â”œâ”€â”€ VariationalCutter.h/cpp
â”‚   â”‚   â”œâ”€â”€ TextureMapper.h/cpp
â”‚   â”‚   â”œâ”€â”€ UVDistortionAnalyzer.h/cpp
â”‚   â”‚   â”œâ”€â”€ SurfaceFiller.h/cpp
â”‚   â”‚   â”œâ”€â”€ BarycentricMapper.h/cpp
â”‚   â”‚   â””â”€â”€ PatternBackMapper.h/cpp
â”‚   â”œâ”€â”€ visualization/
â”‚   â”‚   â”œâ”€â”€ UVVisualization.h/cpp
â”‚   â”‚   â”œâ”€â”€ Renderer.h/cpp
â”‚   â”‚   â””â”€â”€ ImGuiInterface.h/cpp
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ Timer.h
â”‚   â”‚   â”œâ”€â”€ Logger.h
â”‚   â”‚   â””â”€â”€ FileIO.h/cpp
â”‚   â””â”€â”€ main.cpp
â”œâ”€â”€ shaders/
â”‚   â”œâ”€â”€ mesh.vert
â”‚   â”œâ”€â”€ mesh.frag
â”‚   â”œâ”€â”€ distortion.vert
â”‚   â””â”€â”€ distortion.frag
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_distortion.cpp
â”‚   â”œâ”€â”€ test_barycentric.cpp
â”‚   â”œâ”€â”€ test_backmapping.cpp
â”‚   â””â”€â”€ test_integration.cpp
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ simple_uv_unwrap.cpp
â”‚   â”œâ”€â”€ distortion_analysis.cpp
â”‚   â””â”€â”€ pattern_mapping.cpp
â””â”€â”€ data/
    â”œâ”€â”€ models/
    â”‚   â”œâ”€â”€ spot.obj
    â”‚   â”œâ”€â”€ bunny.obj
    â”‚   â””â”€â”€ teapot.obj
    â””â”€â”€ patterns/
        â”œâ”€â”€ grid.svg
        â”œâ”€â”€ hexagon.svg
        â””â”€â”€ spiral.svg
```

## é™„å½•B: æ€§èƒ½ä¼˜åŒ–å»ºè®®

### B.1 å†…å­˜ä¼˜åŒ–
- ä½¿ç”¨å†…å­˜æ± ç®¡ç†å°å¯¹è±¡åˆ†é…
- å®ç°Copy-on-Write forå¤§å‹æ•°æ®ç»“æ„
- åŠæ—¶é‡Šæ”¾ä¸éœ€è¦çš„ä¸­é—´ç»“æœ

### B.2 è®¡ç®—ä¼˜åŒ–
- ä½¿ç”¨SIMDæŒ‡ä»¤åŠ é€Ÿå‘é‡è¿ç®—
- OpenMPå¹¶è¡ŒåŒ–ç‹¬ç«‹çš„ä¸‰è§’å½¢å¤„ç†
- GPUåŠ é€Ÿå¤±çœŸè®¡ç®—ï¼ˆCUDA/OpenCLï¼‰

### B.3 æ¸²æŸ“ä¼˜åŒ–
- å®ç°è§†é”¥å‰”é™¤
- LODç³»ç»Ÿforå¤§è§„æ¨¡ç½‘æ ¼
- å®ä¾‹åŒ–æ¸²æŸ“foré‡å¤å›¾æ¡ˆ

### B.4 ç®—æ³•ä¼˜åŒ–
- ä½¿ç”¨è‡ªé€‚åº”ç²¾åº¦æ§åˆ¶
- å®ç°å¢é‡å¼æ›´æ–°
- ç¼“å­˜é‡å¤è®¡ç®—ç»“æœ

---

**æ–‡æ¡£ç»“æŸ**

æœ¬æŠ€æœ¯è·¯çº¿å›¾æä¾›äº†Miniç‰ˆUnfold3D Demoçš„å®Œæ•´å®æ–½æ–¹æ¡ˆã€‚æ–‡æ¡£å°†éšé¡¹ç›®è¿›å±•æŒç»­æ›´æ–°ã€‚

å¦‚æœ‰ç–‘é—®æˆ–å»ºè®®ï¼Œè¯·è”ç³»é¡¹ç›®æŠ€æœ¯è´Ÿè´£äººã€‚